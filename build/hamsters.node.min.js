var hamsters =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/*
	* Title: this.js
	* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
	* Author: Austin K. Smith
	* Contact: austin@asmithdev.com
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
	* License: Artistic License 2.0
	*/
	
	/* jshint esversion: 6 */
	
	var hamsters = function () {
	  function hamsters() {
	    'use strict';
	
	    _classCallCheck(this, hamsters);
	
	    this.version = '4.2.2';
	    this.maxThreads = this.determineGlobalMaxThreads();
	    this.debug = false;
	    this.persistence = true;
	    this.memoize = false;
	    this.atomics = false;
	    this.legacy = false;
	    this.tools = {
	      randomArray: this.randomArray,
	      aggregateArrays: this.aggregateThreadOutputs,
	      splitArrays: this.splitArrayIntoSubArrays
	    };
	    this.habitat = {
	      browser: this.isBrowser(),
	      worker: this.isWorker(),
	      node: this.isNode(),
	      reactNative: this.isReactNative(),
	      shell: this.isShell(),
	      transferrable: this.supportsTransferrableObjects(),
	      legacy: this.isLegacyEnvironment(),
	      atomics: this.supportsAtomicOperations()
	    };
	    this.pool = {
	      uri: null,
	      tasks: [],
	      errors: [],
	      threads: [],
	      running: [],
	      pending: []
	    };
	    this.run = this.runHamsters;
	    this.promise = this.hamstersPromise;
	    this.loop = this.hamstersLoop;
	    this.parseJson = this.parseJsonOnThread;
	    this.stringifyJson = this.stringifyJsonOnThread;
	    this.init = this.initializeLibrary;
	  }
	
	  _createClass(hamsters, [{
	    key: 'isBrowser',
	    value: function isBrowser() {
	      return (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === "object";
	    }
	  }, {
	    key: 'isNode',
	    value: function isNode() {
	      return (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === "object" && "function" === "function" && !this.isBrowser() && !this.isWorker();
	    }
	  }, {
	    key: 'isWorker',
	    value: function isWorker() {
	      return typeof importScripts === "function";
	    }
	  }, {
	    key: 'isReactNative',
	    value: function isReactNative() {
	      return !this.isNode() && (typeof global === 'undefined' ? 'undefined' : _typeof(global)) === 'object';
	    }
	  }, {
	    key: 'isShell',
	    value: function isShell() {
	      return this.isBrowser() && !this.isNode() && !this.isWorker() && !this.isReactNative();
	    }
	  }, {
	    key: 'supportsTransferrableObjects',
	    value: function supportsTransferrableObjects() {
	      return typeof Uint8Array !== 'undefined';
	    }
	  }, {
	    key: 'isLegacyEnvironment',
	    value: function isLegacyEnvironment() {
	      return this.isShell() || typeof Worker === 'undefined';
	    }
	  }, {
	    key: 'supportsAtomicOperations',
	    value: function supportsAtomicOperations() {
	      return typeof SharedArrayBuffer !== 'undefined';
	    }
	  }, {
	    key: 'initializeLibrary',
	    value: function initializeLibrary(startOptions) {
	      if (typeof startOptions !== 'undefined') {
	        this.processStartOptions(startOptions);
	      }
	      if (this.habitat.browser && !this.habitat.reactNative) {
	        this.setupBrowserSupport();
	      }
	      if (this.habitat.worker && typeof SharedWorker !== 'undefined') {
	        this.setupWorkerSupport();
	      }
	      if (this.habitat.node || this.habitat.reactNative) {
	        if (typeof this.Worker !== 'undefined') {
	          global.Worker = this.Worker;
	        }
	      }
	      if (this.habitat.legacy) {
	        this.wheel = this.legacyHamsterWheel;
	      } else {
	        this.wheel = this.hamsterWheel;
	        this.spawnHamsters();
	      }
	      this.chewGarbage(startOptions);
	    }
	  }, {
	    key: 'isIE',
	    value: function isIE(version) {
	      return new RegExp('msie' + (!isNaN(version) ? '\\s' + version : ''), 'i').test(navigator.userAgent);
	    }
	  }, {
	    key: 'determineGlobalMaxThreads',
	    value: function determineGlobalMaxThreads() {
	      // Default to global thread count of 4
	      var max = 4;
	      // Detect logical core count on machine
	      if (typeof navigator !== 'undefined') {
	        if (typeof navigator.hardwareConcurrency !== 'undefined') {
	          max = navigator.hardwareConcurrency;
	        }
	        // Firefox per origin limit is 20
	        if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && max > 20) {
	          max = 20;
	        }
	      }
	      // Got it
	      return max;
	    }
	  }, {
	    key: 'setupBrowserSupport',
	    value: function setupBrowserSupport() {
	      if (typeof Worker === 'undefined' || ['Kindle/3.0', 'Mobile/8F190', 'IEMobile'].indexOf(navigator.userAgent) !== -1 || this.isIE(10)) {
	        this.habitat.legacy = true;
	      }
	    }
	  }, {
	    key: 'setupWorkerSupport',
	    value: function setupWorkerSupport() {
	      try {
	        var workerBlob = this.generateWorkerBlob();
	        var SharedHamster = new SharedWorker(workerBlob, 'SharedHamsterWheel');
	        this.pool.uri = workerBlob;
	      } catch (e) {
	        this.habitat.legacy = true;
	      }
	    }
	  }, {
	    key: 'processStartOptions',
	    value: function processStartOptions(startOptions) {
	      for (var key in startOptions) {
	        if (startOptions.hasOwnProperty(key)) {
	          hamsters[key] = startOptions[key];
	        }
	      }
	    }
	  }, {
	    key: 'generateWorkerBlob',
	    value: function generateWorkerBlob() {
	      return URL.createObjectURL(this.createBlob('(' + String(this.giveHamsterWork()) + ')();'));
	    }
	  }, {
	    key: 'spawnHamsters',
	    value: function spawnHamsters() {
	      if (this.habitat.browser) {
	        this.pool.uri = this.generateWorkerBlob();
	      }
	      if (this.persistence) {
	        var i = this.maxThreads;
	        for (i; i > 0; i--) {
	          this.pool.threads.push(this.spawnHamster());
	        }
	      }
	    }
	  }, {
	    key: 'spawnHamster',
	    value: function spawnHamster() {
	      if (this.habitat.ie10) {
	        return new Worker('src/common/wheel.min.js');
	      } else if (this.habitat.worker) {
	        return new SharedWorker(this.pool.uri, 'SharedHamsterWheel');
	      } else if (this.habitat.node) {
	        return new Worker(this.giveHamsterWork());
	      } else {
	        return new Worker(this.pool.uri);
	      }
	    }
	  }, {
	    key: 'giveHamsterWork',
	    value: function giveHamsterWork() {
	      if (this.habitat.worker) {
	        return this.workerWorker;
	      }
	      return this.worker;
	    }
	  }, {
	    key: 'createBlob',
	    value: function createBlob(textContent) {
	      if (!Blob) {
	        var BlobMaker = BlobBuilder || WebKitBlobBuilder || MozBlobBuilder || MSBlobBuilder;
	        var blob = new BlobMaker();
	        blob.append([textContent], {
	          type: 'application/javascript'
	        });
	        return blob.getBlob();
	      }
	      return new Blob([textContent], {
	        type: 'application/javascript'
	      });
	    }
	  }, {
	    key: 'workerWorker',
	    value: function workerWorker() {
	      self.addEventListener("connect", function (e) {
	        var port = e.ports[0];
	        port.start();
	        port.addEventListener("message", function (e) {
	          self.params = e.data;
	          self.rtn = {
	            data: [],
	            dataType: params.dataType
	          };
	          var fn = eval("(" + params.fn + ")");
	          if (fn) {
	            fn();
	          }
	          port.postMessage({
	            results: rtn
	          });
	        }, false);
	      }, false);
	    }
	  }, {
	    key: 'worker',
	    value: function worker() {
	      self.typedArrayFromBuffer = function (dataType, buffer) {
	        var types = {
	          'uint32': Uint32Array,
	          'uint16': Uint16Array,
	          'uint8': Uint8Array,
	          'uint8clamped': Uint8ClampedArray,
	          'int32': Int32Array,
	          'int16': Int16Array,
	          'int8': Int8Array,
	          'float32': Float32Array,
	          'float64': Float64Array
	        };
	        if (!types[dataType]) {
	          return buffer;
	        }
	        return new types[dataType](buffer);
	      };
	
	      self.onmessage = function (e) {
	        self.params = e.data;
	        self.rtn = {
	          data: [],
	          dataType: params.dataType
	        };
	        var fn = new Function(params.fn);
	        if (fn) {
	          fn();
	        }
	        if (params.dataType) {
	          rtn.data = self.typedArrayFromBuffer(params.dataType, rtn.data);
	          postMessage({
	            results: rtn
	          }, [rtn.data.buffer]);
	        } else {
	          postMessage({
	            results: rtn
	          });
	        }
	      };
	    }
	  }, {
	    key: 'newTask',
	    value: function newTask(taskOptions) {
	      this.pool.tasks.push(taskOptions);
	      return this.pool.tasks[taskOptions.id];
	    }
	  }, {
	    key: 'legacyHamsterWheel',
	    value: function legacyHamsterWheel(inputArray, hamsterFood, aggregate, onSuccess, task, thread_id, hamster, memoize) {
	      this.trackThread(task, thread_id);
	      if (memoize || this.debug) {
	        this.trackInput(inputArray, thread_id, task, hamsterFood);
	      }
	      legacyProcessor(hamsterFood, inputArray, function (output) {
	        this.chewThread(task, thread_id);
	        task.output[thread_id] = output.data;
	        if (task.workers.length === 0 && task.count === task.threads) {
	          onSuccess(getOutput(task.output, aggregate, output.dataType));
	          this.pool.tasks[task.id] = null;
	          if (this.cache && memoize !== false) {
	            memoize(task.fn, task.input, output.data, output.dataType);
	          }
	        }
	      });
	      task.count += 1; //Thread finished
	    }
	  }, {
	    key: 'chewGarbage',
	    value: function chewGarbage(startOptions) {
	      delete this.init;
	      startOptions = null;
	    }
	  }, {
	    key: 'splitArrayIntoSubArrays',
	    value: function splitArrayIntoSubArrays(array, n) {
	      var i = 0;
	      var threadArrays = [];
	      var size = Math.ceil(array.length / n);
	      if (array.slice) {
	        while (i < array.length) {
	          threadArrays.push(array.slice(i, i += size));
	        }
	      } else {
	        while (i < array.length) {
	          threadArrays.push(array.subarray(i, i += size));
	        }
	      }
	      return threadArrays;
	    }
	  }, {
	    key: 'hamstersLoop',
	    value: function hamstersLoop(input, onSuccess) {
	      var params = {
	        run: this.prepareFunction(input.operator),
	        init: input.startIndex || 0,
	        limit: input.limit,
	        array: input.array,
	        incrementBy: input.incrementBy || 1,
	        dataType: input.dataType || null,
	        worker: this.habitat.worker
	      };
	      this.runHamsters(params, function () {
	        var operator = params.run;
	        if (typeof operator === "string") {
	          if (params.worker) {
	            operator = eval("(" + operator + ")");
	          } else {
	            operator = new Function(operator);
	          }
	        }
	        if (!params.limit) {
	          params.limit = params.array.length;
	        }
	        var i = params.init;
	        for (i; i < params.limit; i += params.incrementBy) {
	          rtn.data[i] = operator(params.array[i]);
	        }
	      }, function (rtn) {
	        onSuccess(rtn);
	      }, input.threads, 1, input.dataType);
	    }
	  }, {
	    key: 'prepareFunction',
	    value: function prepareFunction(functionBody) {
	      if (!this.habitat.legacy) {
	        functionBody = String(functionBody);
	        if (!this.habitat.worker) {
	          var startingIndex = functionBody.indexOf("{") + 1;
	          var endingIndex = functionBody.length - 1;
	          return functionBody.substring(startingIndex, endingIndex);
	        }
	      }
	      return functionBody;
	    }
	  }, {
	    key: 'parseJsonOnThread',
	    value: function parseJsonOnThread(string, onSuccess) {
	      this.runHamsters({ input: string }, function () {
	        rtn.data = JSON.parse(params.input);
	      }, function (output) {
	        onSuccess(output[0]);
	      }, 1);
	    }
	  }, {
	    key: 'stringifyJsonOnThread',
	    value: function stringifyJsonOnThread(json, onSuccess) {
	      this.runHamsters({ input: json }, function () {
	        rtn.data = JSON.stringify(params.input);
	      }, function (output) {
	        onSuccess(output[0]);
	      }, 1);
	    }
	  }, {
	    key: 'hamstersPromise',
	    value: function hamstersPromise(params, functionToRun) {
	      var _this = this;
	
	      return new Promise(function (resolve, reject) {
	        var task = _this.newTask(params);
	        var results = _this.work(task, functionToRun);
	        if (results) {
	          resolve(results);
	        } else {
	          reject('Error processing');
	        }
	      });
	    }
	  }, {
	    key: 'prepareAndSaveTaskOptions',
	    value: function prepareAndSaveTaskOptions(params, functionToRun, onSuccessCallback, numberOfWorkers, aggregateThreadOutputs, dataType, memoize, sortOrder) {
	      var taskOptions = {
	        inputParams: params,
	        id: this.pool.tasks.length,
	        count: 0,
	        performance: [],
	        workers: [],
	        input: [],
	        output: [],
	        threadCount: numberOfWorkers || 1,
	        operator: this.prepareFunction(functionToRun),
	        sortOrder: sortOrder,
	        cacheResults: memoize,
	        aggregateThreadOutputs: aggregateThreadOutputs || false,
	        dataType: dataType ? dataType.toLowerCase() : 'na',
	        onSuccess: onSuccessCallback
	      };
	      taskOptions.inputParams.dataType = taskOptions.dataType;
	      return this.newTask(taskOptions);
	    }
	  }, {
	    key: 'runHamsters',
	    value: function runHamsters(params, functionToRun, onSuccess, numberOfWorkers, aggregateThreadOutputs, dataType, cacheResults, sortOrder) {
	      // Legacy processing use only 1 simulated thread, avoid doing extra work splitting & aggregating
	      var workerCount = this.habitat.legacy ? 1 : numberOfWorkers || 1;
	      var task = this.prepareAndSaveTaskOptions(params, functionToRun, onSuccess, workerCount, aggregateThreadOutputs, dataType, cacheResults, sortOrder);
	      this.hamstersWork(task).then(function (results) {
	        onSuccess(results);
	      }).catch(function (error) {
	        console.error(error.message, error);
	      });
	    }
	  }, {
	    key: 'hamstersWork',
	    value: function hamstersWork(task) {
	      var _this2 = this;
	
	      return new Promise(function (resolve, reject) {
	        var workArray = task.inputParams.array;
	        if (workArray && task.threadCount !== 1) {
	          var i = 0;
	          workArray = _this2.splitArrayIntoSubArrays(workArray, task.threadCount); //Divide our array into equal array sizes
	          while (i < task.threads) {
	            _this2.wheel(workArray[i], task, resolve, reject);
	            i += 1;
	          }
	        } else {
	          _this2.wheel(workArray, task, resolve, reject);
	        }
	      });
	    }
	  }, {
	    key: 'hamsterWheel',
	    value: function hamsterWheel(inputArray, task, resolve, reject) {
	      var threadId = this.pool.running.length;
	      var hamster = {};
	      if (this.maxThreads === threadId) {
	        this.poolThread(inputArray, task, threadId, resolve, reject);
	      } else {
	        if (this.persistence) {
	          hamster = this.pool.threads[threadId];
	        } else {
	          hamster = spawnHamster();
	        }
	        this.trainHamster(threadId, task, hamster, resolve, reject);
	        this.trackThread(task, threadId);
	        hamsterFood.array = inputArray;
	        this.feedHamster(hamster, hamsterFood);
	        task.count += 1; //Increment count, thread is running
	        if (this.debug === 'verbose') {
	          console.info('Spawning Hamster #' + thread_id + ' @ ' + new Date().getTime());
	        }
	      }
	    }
	  }, {
	    key: 'trainHamster',
	    value: function trainHamster(threadId, task, hamster, resolve, reject) {
	      var libraryScope = this;
	      // Handle successful response from a thread
	      var onThreadResponse = function onThreadResponse(e, results) {
	        var threadResponse = e.data.results;
	        libraryScope.chewThread(task, threadId);
	        results = e.data.results;
	        task.output[id] = results.data;
	        if (task.workers.length === 0 && task.count === task.threads) {
	          var output = libraryScope.getOutput(task.output, task.aggregateThreadOutputs, task.dataType);
	          if (task.order) {
	            resolve(sort(output, task.order));
	          } else {
	            resolve(output);
	          }
	          libraryScope.pool.tasks[task.id] = null; //Clean up our task, not needed any longer
	        }
	        if (libraryContext.pool.pending.length !== 0) {
	          libraryContext.processQueue(hamster, libraryContext.pool.pending.shift());
	        } else if (!libraryContext.persistence && !libraryContext.habitat.worker) {
	          hamster.terminate(); //Kill the thread only if no items waiting to run (20-22% performance improvement observed during testing, repurposing threads vs recreating them)
	        }
	      };
	
	      // Handle error response from a thread
	      var onThreadError = function onThreadError(e) {
	        if (!libraryScope.habitat.worker) {
	          hamster.terminate(); //Kill the thread
	        }
	        var error = {
	          timeStamp: Date.now(),
	          threadId: threadId,
	          message: 'Error Hamster #' + id + ': Line ' + e.lineno + ' in ' + e.filename + ': ' + e.message
	        };
	        libraryScope.pool.errors.push(error);
	        reject(error);
	      };
	
	      if (this.habitat.worker) {
	        hamster.port.onmessage = onThreadResponse;
	        hamster.port.onerror = onThreadError;
	      } else {
	        hamster.onmessage = onThreadResponse;
	        hamster.onerror = onThreadError;
	      }
	    }
	  }, {
	    key: 'randomArray',
	    value: function randomArray(count, onSuccess) {
	      var randomArray = [];
	      while (count > 0) {
	        randomArray.push(Math.round(Math.random() * (100 - 1) + 1));
	        count -= 1;
	      }
	      onSuccess(randomArray);
	    }
	  }, {
	    key: 'aggregateThreadOutputs',
	    value: function aggregateThreadOutputs(input, dataType) {
	      if (!dataType || !this.habitat.transferrable) {
	        return input.reduce(function (a, b) {
	          return a.concat(b);
	        });
	      }
	      var i = 0;
	      var len = input.length;
	      var bufferLength = 0;
	      for (i; i < len; i += 1) {
	        bufferLength += input[i].length;
	      }
	      var output = this.processDataType(dataType, bufferLength);
	      var offset = 0;
	      for (i = 0; i < len; i += 1) {
	        output.set(input[i], offset);
	        offset += input[i].length;
	      }
	      return output;
	    }
	  }, {
	    key: 'checkCache',
	    value: function checkCache(fn, input, dataType) {
	      var cachedResult = this.cache[fn];
	      if (cachedResult) {
	        if (cachedResult[0] === input && cachedResult[2] === dataType) {
	          return cachedResult;
	        }
	      }
	    }
	  }, {
	    key: 'memoize',
	    value: function memoize(fn, inputArray, output, dataType) {
	      this.cache[fn] = [inputArray, output, dataType];
	    }
	  }, {
	    key: 'sort',
	    value: function sort(arr, order) {
	      switch (order) {
	        case 'desc':
	        case 'asc':
	          return Array.prototype.sort.call(arr, function (a, b) {
	            return order === 'asc' ? a - b : b - a;
	          });
	        case 'ascAlpha':
	          return arr.sort();
	        case 'descAlpha':
	          return arr.reverse();
	        default:
	          return arr;
	      }
	    }
	  }, {
	    key: 'assignOutput',
	    value: function assignOutput(task, inputArray) {
	      if (!task || !inputArray || !this.habitat.atomics) {
	        return;
	      }
	      task.output = new SharedArrayBuffer(inputArray.length);
	    }
	  }, {
	    key: 'trackInput',
	    value: function trackInput(inputArray, thread_id, task, hamsterFood) {
	      task.input.push({
	        input: inputArray,
	        workerid: thread_id,
	        taskid: task.id,
	        params: hamsterFood,
	        start: Date.now()
	      });
	    }
	  }, {
	    key: 'trackThread',
	    value: function trackThread(task, id) {
	      task.startTime = Date.now();
	      task.workers.push(id); //Keep track of threads scoped to current task
	      this.pool.running.push(id); //Keep track of all currently running threads
	    }
	  }, {
	    key: 'poolThread',
	    value: function poolThread(inputArray, hamsterFood, thread_id, cb, task, agg, memoize) {
	      this.pool.pending.push({
	        memoize: memoize,
	        input: inputArray,
	        params: hamsterFood,
	        workerid: thread_id,
	        onSuccess: cb,
	        task: task,
	        aggregate: agg
	      });
	    }
	  }, {
	    key: 'legacyProcessor',
	    value: function legacyProcessor(params, inputArray, onSuccess) {
	      setTimeout(function () {
	        var rtn = {
	          success: true,
	          data: []
	        };
	        var params = params;
	        params.array = inputArray;
	        params.fn();
	        if (params.dataType && params.dataType != "na") {
	          rtn.data = this.processDataType(params.dataType, rtn.data);
	          rtn.dataType = params.dataType;
	        }
	        onSuccess(rtn);
	      }, 4); //4ms delay (HTML5 spec minimum), simulate threading
	    }
	  }, {
	    key: 'getOutput',
	    value: function getOutput(output, aggregate, dataType) {
	      if (aggregate && output.length <= 20) {
	        return this.aggregateThreadOutputs(output, dataType);
	      }
	      return output;
	    }
	  }, {
	    key: 'processQueue',
	    value: function processQueue(hamster, item) {
	      if (!item) {
	        return;
	      }
	      this.wheel(item.input, item.params, item.aggregate, item.onSuccess, item.task, item.workerid, hamster, item.memoize); //Assign most recently finished thread to queue item
	    }
	  }, {
	    key: 'chewThread',
	    value: function chewThread(task, id) {
	      this.pool.running.splice(this.pool.running.indexOf(id), 1); //Remove thread from running pool
	      task.workers.splice(task.workers.indexOf(id), 1); //Remove thread from task running pool
	    }
	  }, {
	    key: 'processData',
	    value: function processData(dataType, buffer) {
	      var types = {
	        'uint32': Uint32Array,
	        'uint16': Uint16Array,
	        'uint8': Uint8Array,
	        'uint8clamped': Uint8ClampedArray,
	        'int32': Int32Array,
	        'int16': Int16Array,
	        'int8': Int8Array,
	        'float32': Float32Array,
	        'float64': Float64Array
	      };
	      if (!types[dataType]) {
	        return dataType;
	      }
	      return new types[dataType](buffer);
	    }
	  }, {
	    key: 'processDataType',
	    value: function processDataType(dataType, buffer) {
	      if (this.habitat.transferrable) {
	        return this.processData(dataType, buffer);
	      }
	      return buffer;
	    }
	  }, {
	    key: 'feedHamster',
	    value: function feedHamster(hamster, food) {
	      if (this.habitat.worker) {
	        return hamster.port.postMessage(food);
	      }
	      if (this.habitat.ie10) {
	        return hamster.postMessage(food);
	      }
	      var buffers = [],
	          key = void 0;
	      for (key in food) {
	        if (food.hasOwnProperty(key) && food[key] && food[key].buffer) {
	          buffers.push(food[key].buffer);
	        }
	      }
	      return hamster.postMessage(food, buffers);
	    }
	  }]);
	
	  return hamsters;
	}();
	
	module.exports = new hamsters();

/***/ })
/******/ ]);
//# sourceMappingURL=hamsters.node.min.js.map