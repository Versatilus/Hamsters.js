var hamsters =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/*
	 * Title: Hamsters.js
	 * Description: 100% Vanilla Javascript Multithreading & Parallel Execution Library
	 * Author: Austin K. Smith
	 * Contact: austin@asmithdev.com
	 * Copyright: 2015 Austin K. Smith - austin@asmithdev.com
	 * License: Artistic License 2.0
	 */
	
	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _version = __webpack_require__(2);
	
	var _version2 = _interopRequireDefault(_version);
	
	var _habitat = __webpack_require__(3);
	
	var _habitat2 = _interopRequireDefault(_habitat);
	
	var _pool = __webpack_require__(6);
	
	var _pool2 = _interopRequireDefault(_pool);
	
	var _data = __webpack_require__(5);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _wheel = __webpack_require__(7);
	
	var _wheel2 = _interopRequireDefault(_wheel);
	
	var _tools = __webpack_require__(9);
	
	var _tools2 = _interopRequireDefault(_tools);
	
	var _logger = __webpack_require__(8);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _memoizer = __webpack_require__(10);
	
	var _memoizer2 = _interopRequireDefault(_memoizer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var hamstersjs = function () {
	  function hamstersjs() {
	    _classCallCheck(this, hamstersjs);
	
	    this.persistence = true;
	    this.memoize = false;
	    this.atomics = false;
	    this.debug = false;
	    this.version = _version2.default;
	    this.maxThreads = _habitat2.default.logicalThreads;
	    this.tools = _tools2.default;
	    this.habitat = _habitat2.default;
	    this.data = _data2.default;
	    this.pool = _pool2.default;
	    this.logger = _logger2.default;
	    this.memoizer = _memoizer2.default;
	    this.run = this.runHamsters;
	    this.promise = this.hamstersPromise;
	    this.loop = this.loopAbstraction;
	    this.wheel = _pool2.default.selectHamsterWheel();
	    this.init = this.initializeLibrary;
	  }
	
	  _createClass(hamstersjs, [{
	    key: 'initializeLibrary',
	    value: function initializeLibrary(startOptions) {
	      this.logger.info('Preparing the hamster wheels & readying hamsters');
	      if (typeof startOptions !== 'undefined') {
	        this.processStartOptions(startOptions);
	      }
	      this.pool.spawnHamsters(this.persistence, this.wheel, this.maxThreads);
	    }
	  }, {
	    key: 'processStartOptions',
	    value: function processStartOptions(startOptions) {
	      var habitatKeys = ['worker', 'sharedWorker', 'legacy'];
	      for (var key in startOptions) {
	        if (startOptions.hasOwnProperty(key)) {
	          if (habitatKeys.indexOf(key.toLowerCase()) !== -1) {
	            hamsters.habitat[key] = startOptions[key];
	          } else {
	            hamsters[key] = startOptions[key];
	          }
	        }
	      }
	    }
	  }, {
	    key: 'newTask',
	    value: function newTask(taskOptions) {
	      var index = this.pool.tasks.push(taskOptions);
	      return this.pool.tasks[index - 1];
	    }
	  }, {
	    key: 'loopAbstraction',
	    value: function loopAbstraction(input, onSuccess) {
	      var params = new hamstersLoop.options(input, this.habitat.webWorker);
	      this.runHamsters(params, function (rtn) {
	        onSuccess(rtn);
	      }, input.threads, true, input.dataType);
	    }
	  }, {
	    key: 'legacyHamsterWheel',
	    value: function legacyHamsterWheel(threadId, task, resolve, reject) {
	      this.pool.trackThread(task, threadId);
	      var dataArray = this.data.arrayFromIndex(task.input.array, task.indexes[threadId]);
	      hamsterWheel.legacy(task, dataArray, resolve, reject);
	      task.count += 1; //Thread finished
	    }
	  }, {
	    key: 'hamstersTask',
	    value: function hamstersTask(params, functionToRun, scope) {
	      this.id = scope.pool.tasks.length;
	      this.threads = params.threads || 1;
	      this.count = 0;
	      this.input = params;
	      this.aggregate = params.aggregate || true;
	      this.output = [];
	      this.workers = [];
	      this.operator = scope.data.prepareJob(functionToRun);
	      this.memoize = params.memoize || false;
	      this.dataType = params.dataType ? params.dataType.toLowerCase() : null;
	      if (params.array) {
	        this.indexes = scope.data.determineSubArrays(params.array, this.threads);
	      }
	    }
	  }, {
	    key: 'hamstersPromise',
	    value: function hamstersPromise(params, functionToRun) {
	      var _this = this;
	
	      return new Promise(function (resolve, reject) {
	        var task = new _this.hamstersTask(params, functionToRun, _this);
	        var logger = _this.logger;
	        _this.pool.scheduleTask(task, _this.wheel, _this.maxThreads).then(function (results) {
	          resolve(results);
	        }).catch(function (error) {
	          logger.error(error.messsage, reject);
	        });
	      });
	    }
	  }, {
	    key: 'runHamsters',
	    value: function runHamsters(params, functionToRun, onSuccess) {
	      var task = new this.hamstersTask(params, functionToRun, this);
	      var logger = this.logger;
	      this.pool.scheduleTask(task, this.wheel, this.maxThreads).then(function (results) {
	        onSuccess(results);
	      }).catch(function (error) {
	        logger.error(error.messsage);
	      });
	    }
	  }, {
	    key: 'hamsterWheel',
	    value: function hamsterWheel(task, resolve, reject) {
	      var threadId = this.pool.running.length;
	      if (this.maxThreads === threadId) {
	        return this.pool.queueWork(task, threadId, resolve, reject);
	      }
	      var hamsterFood = this.data.prepareMeal(task, threadId);
	      var hamster = taskhis.pool.grabHamster(threadId, this.persistence, this.habitat, this.worker, this.data);
	      this.trainHamster(threadId, task, hamster, resolve, reject);
	      this.pool.trackThread(task, threadId);
	      this.data.feedHamster(hamster, hamsterFood);
	      task.count += 1; //Increment count, thread is running
	    }
	  }, {
	    key: 'returnOutput',
	    value: function returnOutput(task, resolve) {
	      var output = this.data.getOutput(task, this.habitat.transferrable);
	      if (task.sort) {
	        output = this.data.sortOutput(output, task.sort);
	      }
	      this.pool.tasks[task.id] = null; //Clean up our task, not needed any longer
	      resolve(output);
	    }
	  }, {
	    key: 'trainHamster',
	    value: function trainHamster(threadId, task, hamster, resolve, reject) {
	      var scope = this;
	      // Handle successful response from a thread
	      function onThreadResponse(messsage) {
	        var results = message.data;
	        scope.pool.destroyThread(task, threadId);
	        task.output[threadId] = results.data;
	        if (task.workers.length === 0 && task.count === task.threads) {
	          scope.returnOutput(task, resolve);
	        }
	        if (scope.pool.pending.length !== 0) {
	          scope.pool.processQueue(scope.pool.pending.shift());
	        }
	        if (!scope.persistence && !scope.habitat.webWorker) {
	          hamster.terminate(); //Kill the thread only if no items waiting to run (20-22% performance improvement observed during testing, repurposing threads vs recreating them)
	        }
	      }
	      // Handle error response from a thread
	      function onThreadError(error) {
	        this.logger.errorFromThread(error, reject);
	      }
	      // Register on message/error handlers
	      if (this.habitat.webWorker) {
	        hamster.port.onmessage = onThreadResponse;
	        hamster.port.onerror = onThreadError;
	      } else {
	        hamster.onmessage = onThreadResponse;
	        hamster.onerror = onThreadError;
	      }
	    }
	  }]);
	
	  return hamstersjs;
	}();
	
	var hamsters = new hamstersjs();
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = hamsters;
	}

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	/* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/*
	* Title: Hamsters.js
	* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
	* Author: Austin K. Smith
	* Contact: austin@asmithdev.com
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
	* License: Artistic License 2.0
	*/
	
	'use strict';
	
	var majorVersion = 4;
	var minorVersion = 2;
	var patchVersion = 2;
	var hamstersVersion = majorVersion + '.' + minorVersion + '.' + patchVersion;
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = hamstersVersion;
	}

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/*
	* Title: Hamsters.js
	* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
	* Author: Austin K. Smith
	* Contact: austin@asmithdev.com
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
	* License: Artistic License 2.0
	*/
	
	var _data = __webpack_require__(5);
	
	var _data2 = _interopRequireDefault(_data);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	'use strict';
	
	var habitat = function () {
	  function habitat() {
	    _classCallCheck(this, habitat);
	
	    this.browser = this.isBrowser();
	    this.webWorker = this.isWebWorker();
	    this.node = this.isNode();
	    this.reactNative = this.isReactNative();
	    this.shell = this.isShell();
	    this.transferrable = this.supportsTransferrableObjects();
	    this.legacy = this.isLegacyEnvironment();
	    this.atomics = this.supportsAtomicOperations();
	    this.proxies = this.supportsProxies();
	    this.isIE = this.isInternetExplorer;
	    this.logicalThreads = this.determineGlobalThreads();
	    this.Worker = this.locateWorkerObject();
	    this.sharedWorker = this.locateSharedWorkerObject();
	  }
	
	  _createClass(habitat, [{
	    key: 'determineGlobalThreads',
	    value: function determineGlobalThreads() {
	      var max = 4;
	      if (typeof navigator !== 'undefined') {
	        if (typeof navigator.hardwareConcurrency !== 'undefined') {
	          max = navigator.hardwareConcurrency;
	        }
	        if (max > 20 && navigator.userAgent.toLowerCase().indexOf('firefox') !== -1) {
	          max = 20;
	        }
	      }
	      if (this.isNode() && typeof os !== 'undefined') {
	        max = os.cpus().length;
	      }
	      return max;
	    }
	  }, {
	    key: 'locateWorkerObject',
	    value: function locateWorkerObject() {
	      return Worker || null;
	    }
	  }, {
	    key: 'locateSharedWorkerObject',
	    value: function locateSharedWorkerObject() {
	      return SharedWorker || null;
	    }
	  }, {
	    key: 'isBrowser',
	    value: function isBrowser() {
	      return (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === "object";
	    }
	  }, {
	    key: 'isInternetExplorer',
	    value: function isInternetExplorer(version) {
	      return new RegExp('msie' + (!isNaN(version) ? '\\s' + version : ''), 'i').test(navigator.userAgent);
	    }
	  }, {
	    key: 'isNode',
	    value: function isNode() {
	      return (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === "object" && "function" === "function" && !this.isBrowser() && !this.isWebWorker();
	    }
	  }, {
	    key: 'isWebWorker',
	    value: function isWebWorker() {
	      return typeof importScripts === "function";
	    }
	  }, {
	    key: 'isReactNative',
	    value: function isReactNative() {
	      return !this.isNode() && (typeof global === 'undefined' ? 'undefined' : _typeof(global)) === 'object';
	    }
	  }, {
	    key: 'isShell',
	    value: function isShell() {
	      return this.isBrowser() && !this.isNode() && !this.isWebWorker() && !this.isReactNative();
	    }
	  }, {
	    key: 'supportsTransferrableObjects',
	    value: function supportsTransferrableObjects() {
	      return typeof Uint8Array !== 'undefined';
	    }
	  }, {
	    key: 'isLegacyEnvironment',
	    value: function isLegacyEnvironment() {
	      // Force legacy mode for known devices that don't support threading
	      if (this.isBrowser() && !this.isReactNative()) {
	        var isIE10 = this.habitat.isIE(10);
	        var userAgent = navigator.userAgent;
	        var lacksWorkerSupport = typeof this.Worker === 'undefined';
	        var legacyAgents = ['Kindle/3.0', 'Mobile/8F190', 'IEMobile'];
	        if (lacksWorkerSupport || legacyAgents.indexOf(userAgent) !== -1 || isIE10) {
	          this.legacy = true;
	        }
	      }
	      // Detect sharedWorker support for use within webworkers
	      if (this.webWorker && typeof this.SharedWorker !== 'undefined') {
	        try {
	          var workerBlob = _data2.default.generateBlob();
	          var SharedHamster = new this.SharedWorker(workerBlob, 'SharedHamsterWheel');
	          _data2.default.workerURI = workerBlob;
	        } catch (e) {
	          this.legacy = true;
	        }
	      }
	      // Final check, if we're in a shell environment or we have no worker object use legacy mode
	      if (!this.legacy) {
	        return this.isShell() || !this.locateWorkerObject();
	      }
	    }
	  }, {
	    key: 'supportsAtomicOperations',
	    value: function supportsAtomicOperations() {
	      return typeof SharedArrayBuffer !== 'undefined';
	    }
	  }, {
	    key: 'supportsProxies',
	    value: function supportsProxies() {
	      return typeof Proxy !== 'undefined';
	    }
	  }]);
	
	  return habitat;
	}();
	
	var hamstersHabitat = new habitat();
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = hamstersHabitat;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), (function() { return this; }())))

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	/* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/*
	* Title: Hamsters.js
	* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
	* Author: Austin K. Smith
	* Contact: austin@asmithdev.com
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
	* License: Artistic License 2.0
	*/
	
	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var data = function () {
	  function data() {
	    _classCallCheck(this, data);
	
	    this.randomArray = this.randomArray;
	    this.aggregateArrays = this.aggregateThreadOutputs;
	    this.splitArrays = this.splitArrayIntoSubArrays;
	    this.createBlob = this.createDataBlob;
	    this.generateBlob = this.generateWorkerBlob;
	    this.determineSubArrays = this.determineSubArrayIndexes;
	    this.arrayFromIndex = this.subArrayFromIndex;
	    this.processDataType = this.processDataType;
	    this.sortOutput = this.sortArray;
	    this.getOutput = this.prepareOutput;
	    this.prepareJob = this.prepareFunction;
	    this.feedHamster = this.messageWorker;
	    this.prepareMeal = this.prepareHamsterFood;
	    this.workerURI = null;
	  }
	
	  _createClass(data, [{
	    key: 'prepareHamsterFood',
	    value: function prepareHamsterFood(task, threadId) {
	      var hamsterFood = {};
	      for (var key in task.input) {
	        if (task.input.hasOwnProperty(key) && key !== 'array') {
	          hamsterFood[key] = task.input[key];
	        }
	      }
	      if (task.indexes && task.threads !== 1) {
	        hamsterFood.array = this.data.arrayFromIndex(task.input.array, task.indexes[threadId]);
	      } else {
	        hamsterFood.array = task.input.array;
	      }
	      if (task.operator && !hamsterFood.fn) {
	        hamsterFood.fn = task.operator;
	      }
	      return hamsterFood;
	    }
	  }, {
	    key: 'messageWorker',
	    value: function messageWorker(hamster, hamsterFood) {
	      if (this.habitat.webWorker) {
	        return hamster.port.postMessage(hamsterFood);
	      }
	      if (this.habitat.ie10) {
	        return hamster.postMessage(hamsterFood);
	      }
	      return hamster.postMessage(hamsterFood, this.prepareTransferBuffers(hamsterFood));
	    }
	  }, {
	    key: 'prepareTransferBuffers',
	    value: function prepareTransferBuffers(hamsterFood) {
	      var buffers = [];
	      var key = null;
	      if (this.habitat.transferrable) {
	        for (key in hamsterFood) {
	          if (hamsterFood.hasOwnProperty(key) && hamsterFood[key]) {
	            if (hamsterFood[key].buffer) {
	              buffers.push(hamsterFood[key].buffer);
	            } else if (Array.isArray(hamsterFood[key]) && typeof ArrayBuffer !== 'undefined') {
	              buffers.push(new ArrayBuffer(hamsterFood[key]));
	            }
	          }
	        }
	      }
	      return buffers;
	    }
	  }, {
	    key: 'prepareFunction',
	    value: function prepareFunction(functionBody) {
	      if (!this.habitat.legacy) {
	        functionBody = String(functionBody);
	        if (!this.habitat.webWorker) {
	          var startingIndex = functionBody.indexOf("{") + 1;
	          var endingIndex = functionBody.length - 1;
	          return functionBody.substring(startingIndex, endingIndex);
	        }
	      }
	      return functionBody;
	    }
	  }, {
	    key: 'generateWorkerBlob',
	    value: function generateWorkerBlob(workerLogic) {
	      var functionString = '(' + String(workerLogic) + ')();';
	      var hamsterBlob = this.createBlob(functionString);
	      return URL.createObjectURL(hamsterBlob);
	    }
	  }, {
	    key: 'processDataType',
	    value: function processDataType(dataType, buffer, transferrable) {
	      if (transferrable) {
	        return this.typedArrayFromBuffer(dataType, buffer);
	      }
	      return buffer;
	    }
	  }, {
	    key: 'prepareOutput',
	    value: function prepareOutput(task, transferrable) {
	      if (task.aggregate && task.threads !== 1) {
	        return this.aggregateThreadOutputs(task.output, task.dataType, transferrable);
	      }
	      return task.output;
	    }
	  }, {
	    key: 'sortArray',
	    value: function sortArray(arr, order) {
	      switch (order) {
	        case 'desc':
	        case 'asc':
	          return Array.prototype.sort.call(arr, function (a, b) {
	            return order === 'asc' ? a - b : b - a;
	          });
	        case 'ascAlpha':
	          return arr.sort();
	        case 'descAlpha':
	          return arr.reverse();
	        default:
	          return arr;
	      }
	    }
	  }, {
	    key: 'typedArrayFromBuffer',
	    value: function typedArrayFromBuffer(dataType, buffer) {
	      var types = {
	        'uint32': Uint32Array,
	        'uint16': Uint16Array,
	        'uint8': Uint8Array,
	        'uint8clamped': Uint8ClampedArray,
	        'int32': Int32Array,
	        'int16': Int16Array,
	        'int8': Int8Array,
	        'float32': Float32Array,
	        'float64': Float64Array
	      };
	      if (!types[dataType]) {
	        return dataType;
	      }
	      return new types[dataType](buffer);
	    }
	  }, {
	    key: 'determineSubArrayIndexes',
	    value: function determineSubArrayIndexes(array, n) {
	      var i = 0;
	      var size = Math.ceil(array.length / n);
	      var indexes = [];
	      while (i < array.length) {
	        var start = i;
	        var end = i + size - 1;
	        indexes.push({
	          start: start,
	          end: end
	        });
	        i += size;
	      }
	      return indexes;
	    }
	  }, {
	    key: 'subArrayFromIndex',
	    value: function subArrayFromIndex(array, index) {
	      if (array.slice) {
	        return array.slice(index.start, index.end);
	      } else {
	        return array.subarray(index.start, index.end);
	      }
	    }
	  }, {
	    key: 'createDataBlob',
	    value: function createDataBlob(textContent) {
	      if (typeof Blob === 'undefined') {
	        var BlobMaker = BlobBuilder || WebKitBlobBuilder || MozBlobBuilder || MSBlobBuilder;
	        var blob = new BlobMaker();
	        blob.append([textContent], {
	          type: 'application/javascript'
	        });
	        return blob.getBlob();
	      }
	      return new Blob([textContent], {
	        type: 'application/javascript'
	      });
	    }
	  }, {
	    key: 'randomArray',
	    value: function randomArray(count, onSuccess) {
	      var randomArray = [];
	      while (count > 0) {
	        randomArray.push(Math.round(Math.random() * (100 - 1) + 1));
	        count -= 1;
	      }
	      onSuccess(randomArray);
	    }
	  }, {
	    key: 'aggregateThreadOutputs',
	    value: function aggregateThreadOutputs(input, dataType, transferrable) {
	      if (!dataType || !transferrable) {
	        return input.reduce(function (a, b) {
	          return a.concat(b);
	        });
	      }
	      var i = 0;
	      var len = input.length;
	      var bufferLength = 0;
	      for (i; i < len; i += 1) {
	        bufferLength += input[i].length;
	      }
	      var output = this.processDataType(dataType, bufferLength, transferrable);
	      var offset = 0;
	      for (i = 0; i < len; i += 1) {
	        output.set(input[i], offset);
	        offset += input[i].length;
	      }
	      return output;
	    }
	  }, {
	    key: 'splitArrayIntoSubArrays',
	    value: function splitArrayIntoSubArrays(array, n) {
	      var i = 0;
	      var threadArrays = [];
	      var size = Math.ceil(array.length / n);
	      if (array.slice) {
	        while (i < array.length) {
	          threadArrays.push(array.slice(i, i += size));
	        }
	      } else {
	        while (i < array.length) {
	          threadArrays.push(array.subarray(i, i += size));
	        }
	      }
	      return threadArrays;
	    }
	  }]);
	
	  return data;
	}();
	
	var hamstersData = new data();
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = hamstersData;
	}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/*
	* Title: Hamsters.js
	* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
	* Author: Austin K. Smith
	* Contact: austin@asmithdev.com
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
	* License: Artistic License 2.0
	*/
	
	var _data = __webpack_require__(5);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _habitat = __webpack_require__(3);
	
	var _habitat2 = _interopRequireDefault(_habitat);
	
	var _wheel = __webpack_require__(7);
	
	var _wheel2 = _interopRequireDefault(_wheel);
	
	var _logger = __webpack_require__(8);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	'use strict';
	
	var pool = function () {
	  function pool() {
	    _classCallCheck(this, pool);
	
	    this.tasks = [];
	    this.threads = [];
	    this.running = [];
	    this.pending = [];
	    this.queueWork = this.addWorkToPending;
	    this.beginWork = this.startTask;
	    this.fetchHamster = this.grabHamster;
	    this.selectHamsterWheel = this.selectHamsterWheel;
	    this.markThreadReady = this.removeThreadFromRunning;
	    this.trackThread = this.keepTrackOfThread;
	  }
	
	  _createClass(pool, [{
	    key: 'addWorkToPending',
	    value: function addWorkToPending(task, id, resolve, reject) {
	      this.pending.push({
	        item: task,
	        threadId: id,
	        promiseResolve: resolve,
	        promiseReject: reject
	      });
	    }
	  }, {
	    key: 'grabHamster',
	    value: function grabHamster(threadId, persistence, worker) {
	      if (persistence) {
	        return this.threads[threadId];
	      }
	      return this.spawnHamster(_habitat2.default, worker, _data2.default.workerURI);
	    }
	  }, {
	    key: 'newTask',
	    value: function newTask(taskOptions) {
	      var index = this.pool.tasks.push(taskOptions);
	      return this.pool.tasks[index - 1];
	    }
	  }, {
	    key: 'removeThreadFromRunning',
	    value: function removeThreadFromRunning(task, id) {
	      this.running.splice(this.running.indexOf(id), 1); //Remove thread from running pool
	      task.workers.splice(task.workers.indexOf(id), 1); //Remove thread from task running pool
	    }
	  }, {
	    key: 'processQueue',
	    value: function processQueue(hamster, item) {
	      if (!item) {
	        return;
	      }
	      this.wheel(item.input, item.params, item.aggregate, item.onSuccess, item.task, item.workerid, hamster, item.memoize); //Assign most recently finished thread to queue item
	    }
	  }, {
	    key: 'startTask',
	    value: function startTask(task, resolve, reject) {
	      return this.wheel(task, resolve, reject);
	    }
	  }, {
	    key: 'spawnHamsters',
	    value: function spawnHamsters(persistence, wheel, maxThreads) {
	      var workerURI = null;
	      if (_habitat2.default.legacy) {
	        return;
	      }
	      if (_habitat2.default.browser) {
	        workerURI = _data2.default.generateBlob(wheel);
	      }
	      if (persistence) {
	        _logger2.default.info(maxThreads + ' Logical Threads Detected, Spawning ' + maxThreads + ' Hamsters');
	        for (maxThreads; maxThreads > 0; maxThreads--) {
	          this.threads.push(this.spawnHamster(wheel, workerURI));
	        }
	        _logger2.default.info(this.threads.length + ' hamsters ready and awaiting instructions');
	      }
	    }
	  }, {
	    key: 'spawnHamster',
	    value: function spawnHamster(wheel, workerURI) {
	      if (_habitat2.default.ie10) {
	        return new _habitat2.default.Worker(wheel);
	      }
	      if (_habitat2.default.webWorker) {
	        return new _habitat2.default.SharedWorker(workerURI, 'SharedHamsterWheel');
	      }
	      if ((_habitat2.default.node || _habitat2.default.reactNative) && !_habitat2.default.browser) {
	        return new _habitat2.default.Worker(wheel);
	      }
	      return new _habitat2.default.Worker(workerURI);
	    }
	  }, {
	    key: 'selectHamsterWheel',
	    value: function selectHamsterWheel() {
	      if (_habitat2.default.legacy) {
	        return _wheel2.default.legacy;
	      }
	      if (_habitat2.default.webWorker) {
	        return _wheel2.default.worker;
	      }
	      return _wheel2.default.regular;
	    }
	  }, {
	    key: 'scheduleTask',
	    value: function scheduleTask(task, wheel, maxThreads) {
	      if (this.running.length === maxThreads) {
	        return this.addWorkToPending();
	      }
	      return new Promise(function (resolve, reject) {
	        var i = 0;
	        while (i < task.threads) {
	          wheel(task, resolve, reject);
	          i += 1;
	        }
	      });
	    }
	  }, {
	    key: 'keepTrackOfThread',
	    value: function keepTrackOfThread(task, id) {
	      task.workers.push(id); //Keep track of threads scoped to current task
	      this.running.push(id); //Keep track of all currently running threads
	    }
	  }]);
	
	  return pool;
	}();
	
	var hamsterPool = new pool();
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = hamsterPool;
	}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/*
	* Title: Hamsters.js
	* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
	* Author: Austin K. Smith
	* Contact: austin@asmithdev.com
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
	* License: Artistic License 2.0
	*/
	
	var _data = __webpack_require__(5);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _habitat = __webpack_require__(3);
	
	var _habitat2 = _interopRequireDefault(_habitat);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	'use strict';
	
	var wheel = function () {
	  function wheel() {
	    _classCallCheck(this, wheel);
	
	    this.worker = this.workerScaffold;
	    this.regular = this.regularScaffold;
	    this.legacy = this.legacyScaffold;
	  }
	
	  _createClass(wheel, [{
	    key: 'workerScaffold',
	    value: function workerScaffold() {
	      'use strict';
	
	      var params = {};
	      var rtn = {};
	
	      function setDefaults(incomingMessage) {
	        params = incomingMessage.data;
	        rtn = {
	          data: [],
	          dataType: params.dataType
	        };
	      }
	
	      addEventListener('connect', function (incomingConnection) {
	        var port = incomingConnection.ports[0];
	        port.start();
	        port.addEventListener('message', function (incomingMessage) {
	          setDefaults(incomingMessage);
	          eval("(" + params.fn + ")")();
	          port.postMessage({
	            results: rtn
	          });
	        }, false);
	      }, false);
	    }
	  }, {
	    key: 'regularScaffold',
	    value: function regularScaffold() {
	      'use strict';
	
	      var params = {};
	      var rtn = {};
	
	      function setDefaults(incomingMessage) {
	        params = incomingMessage.data;
	        rtn = {
	          data: [],
	          dataType: params.dataType ? params.dataType.toLowerCase() : null
	        };
	      }
	
	      function prepareReturn(returnObject) {
	        var dataType = returnObject.dataType;
	        if (dataType) {
	          returnObject.data = typedArrayFromBuffer(dataType, returnObject.data);
	        }
	        return returnObject;
	      }
	
	      function typedArrayFromBuffer(dataType, buffer) {
	        var types = {
	          'uint32': Uint32Array,
	          'uint16': Uint16Array,
	          'uint8': Uint8Array,
	          'uint8clamped': Uint8ClampedArray,
	          'int32': Int32Array,
	          'int16': Int16Array,
	          'int8': Int8Array,
	          'float32': Float32Array,
	          'float64': Float64Array
	        };
	        if (!types[dataType]) {
	          return buffer;
	        }
	        return new types[dataType](buffer);
	      }
	
	      function prepareTransferBuffers(hamsterFood) {
	        var buffers = [];
	        var key = null;
	        for (key in hamsterFood) {
	          if (hamsterFood.hasOwnProperty(key) && hamsterFood[key]) {
	            if (hamsterFood[key].buffer) {
	              buffers.push(hamsterFood[key].buffer);
	            } else if (Array.isArray(hamsterFood[key]) && typeof ArrayBuffer !== 'undefined') {
	              buffers.push(new ArrayBuffer(hamsterFood[key]));
	            }
	          }
	        }
	        return buffers;
	      }
	
	      function onmessage(incomingMessage) {
	        setDefaults(incomingMessage);
	        new Function(params.fn)();
	        postMessage(prepareReturn(rtn), prepareTransferBuffers(rtn));
	      };
	    }
	  }, {
	    key: 'legacyScaffold',
	    value: function legacyScaffold(params, resolve, reject) {
	      setTimeout(function () {
	        var rtn = {
	          data: [],
	          dataType: params.dataType ? params.dataType.toLowerCase() : null
	        };
	        params.fn();
	        if (params.dataType) {
	          rtn.data = _data2.default.processDataType(params.dataType, rtn.data, _habitat2.default.transferable);
	          rtn.dataType = params.dataType;
	        }
	        resolve(rtn);
	      }, 4); //4ms delay (HTML5 spec minimum), simulate threading
	    }
	  }]);
	
	  return wheel;
	}();
	
	;
	
	var hamstersWheel = new wheel();
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = hamstersWheel;
	}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/*
	* Title: Hamsters.js
	* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
	* Author: Austin K. Smith
	* Contact: austin@asmithdev.com
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
	* License: Artistic License 2.0
	*/
	
	var _version = __webpack_require__(2);
	
	var _version2 = _interopRequireDefault(_version);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	'use strict';
	
	var logger = function () {
	  function logger() {
	    _classCallCheck(this, logger);
	
	    this.logBook = {
	      error: [],
	      warning: [],
	      info: []
	    };
	    this.info = this.infoLog;
	    this.warning = this.warningLog;
	    this.error = this.errorLog;
	    this.errorFromThread = this.errorFromThread;
	    this.saveLogEntry = this.saveToLogBook;
	    this.getLogEntries = this.fetchLogBook;
	    this.searchLogEntries = this.searchLogBook;
	  }
	
	  _createClass(logger, [{
	    key: 'infoLog',
	    value: function infoLog(message) {
	      var timeStamp = Date.now();
	      var timeStampedMessage = 'Hamsters.js v' + _version2.default + ' Info: ' + message + ' @ ' + timeStamp;
	      this.saveLogEntry('info', timeStampedMessage);
	      console.info(timeStampedMessage);
	    }
	  }, {
	    key: 'warningLog',
	    value: function warningLog(message) {
	      var timeStamp = Date.now();
	      var timeStampedMessage = 'Hamsters.js v' + _version2.default + ' Warning: ' + message + ' @ ' + timeStamp;
	      this.saveLogEntry('warning', timeStampedMessage);
	      console.warning(timeStampedMessage);
	    }
	  }, {
	    key: 'errorLog',
	    value: function errorLog(message, reject) {
	      var timeStamp = Date.now();
	      var timeStampedMessage = 'Hamsters.js v' + _version2.default + ' Error: ' + message + ' @ ' + timeStamp;
	      this.saveLogEntry('error', timeStampedMessage);
	      console.error(timeStampedMessage);
	      reject(timeStampedMessage);
	    }
	  }, {
	    key: 'errorFromThread',
	    value: function errorFromThread(error, reject) {
	      var errorMessage = '#' + error.lineno + ' in ' + error.filename + ': ' + error.message;
	      this.errorLog(errorMessage, reject);
	    }
	  }, {
	    key: 'saveToLogBook',
	    value: function saveToLogBook(eventType, message) {
	      this.logBook[eventType].push(message);
	    }
	  }, {
	    key: 'fetchLogBook',
	    value: function fetchLogBook(eventType) {
	      if (eventType) {
	        return this.logBook[eventType];
	      }
	      return this.logBook;
	    }
	  }, {
	    key: 'findStringInLogBook',
	    value: function findStringInLogBook(logBookEntries, string) {
	      var searchResults = [];
	      var i = 0;
	      for (i; i < logBookEntries.length; i++) {
	        if (logBookEntries[i].indexOf(string) !== -1) {
	          searchResults.push(logBookEntries[i]);
	        }
	      }
	      return searchResults;
	    }
	  }, {
	    key: 'findStringInLogBookAllTypes',
	    value: function findStringInLogBookAllTypes(logBook, searchString) {
	      var searchResults = [];
	      var key = void 0,
	          eventTypeResults = void 0,
	          tmpEntries = null;
	      for (key in logBook) {
	        if (logBook.hasOwnProperty(key)) {
	          tmpEntries = logBook[key];
	          eventTypeResults = this.findStringInLogBook(tmpEntries, searchString);
	        }
	      }
	      return searchResults;
	    }
	  }, {
	    key: 'searchLogBook',
	    value: function searchLogBook(searchString, eventType) {
	      var finalResults = [];
	      var eventTypeResults = void 0;
	      if (eventType) {
	        tmpEntries = this.logBook[eventType];
	        finalResults = this.findStringInLogBook(tmpEntries, string);
	      } else {
	        var allResults = this.findStringInLogBookAllTypes(this.logBook);
	        if (all.length !== 0) {
	          finalResults = [finalResults, eventTypeResults].reduce(function (a, b) {
	            return a.concat(b);
	          });
	        }
	      }
	      return {
	        total: finalResults.length,
	        results: finalResults
	      };
	    }
	  }]);
	
	  return logger;
	}();
	
	var hamstersLogger = new logger();
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = hamstersLogger;
	}

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	/* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/*
	* Title: Hamsters.js
	* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
	* Author: Austin K. Smith
	* Contact: austin@asmithdev.com
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
	* License: Artistic License 2.0
	*/
	
	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var tools = function () {
	  function tools() {
	    _classCallCheck(this, tools);
	
	    this.randomArray = this.randomArray;
	    this.parseJson = this.parseJsonOnThread;
	    this.stringifyJson = this.stringifyJsonOnThread;
	  }
	
	  _createClass(tools, [{
	    key: 'randomArray',
	    value: function randomArray(inputAmount, onSuccess) {
	      var array = [];
	      while (inputAmount > 0) {
	        array[inputAmount] = Math.round(Math.random() * (100 - 1) + 1);
	        inputAmount -= 1;
	      }
	      onSuccess(array);
	    }
	  }, {
	    key: 'parseJsonOnThread',
	    value: function parseJsonOnThread(string, onSuccess) {
	      this.runHamsters({ input: string }, function () {
	        rtn.data = JSON.parse(params.input);
	      }, function (output) {
	        onSuccess(output[0]);
	      }, 1);
	    }
	  }, {
	    key: 'stringifyJsonOnThread',
	    value: function stringifyJsonOnThread(json, onSuccess) {
	      this.runHamsters({ input: json }, function () {
	        rtn.data = JSON.stringify(params.input);
	      }, function (output) {
	        onSuccess(output[0]);
	      }, 1);
	    }
	  }]);
	
	  return tools;
	}();
	
	var hamstersTools = new tools();
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = hamstersTools;
	}

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	/* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/*
	* Title: Hamsters.js
	* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers
	* Author: Austin K. Smith
	* Contact: austin@asmithdev.com
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com
	* License: Artistic License 2.0
	*/
	
	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var memoizer = function () {
	  function memoizer() {
	    _classCallCheck(this, memoizer);
	
	    this.maxCacheEntries = 25;
	    this.cacheEntries = [];
	    this.itemCached = this.isItemCached;
	    this.fetchItem = this.fetchItemFromCache;
	    this.saveItem = this.saveItemToCache;
	  }
	
	  _createClass(memoizer, [{
	    key: 'isItemCached',
	    value: function isItemCached(input, method) {
	      return !!this.fetchItem({ fn: method, data: input }) || false;
	    }
	  }, {
	    key: 'fetchItemFromCache',
	    value: function fetchItemFromCache(cacheItem) {
	      var cachedResult = null;
	      for (var key in this.cache) {
	        if (this.cache.hasOwnProperty(key)) {
	          if (cacheItem[key].fn === cacheItem.fn) {
	            if (cacheItem[key].input === cacheItem.data) {
	              cachedResult = cacheItem[key].input;
	            }
	          }
	        }
	      }
	      return cachedResult || false;
	    }
	  }, {
	    key: 'saveItemToCache',
	    value: function saveItemToCache(method, data, maxCacheEntries) {
	      var itemToCache = {
	        fn: method,
	        input: data
	      };
	      var cachedItems = this.cacheEntries;
	      if (cachedItems.length < maxCacheEntries) {
	        cachedItems.push(itemToCache);
	      } else {
	        cachedItems.splice(0, 0, itemToCache);
	      }
	      this.cacheEntries = cachedItems;
	    }
	  }]);
	
	  return memoizer;
	}();
	
	var hamstersMemoizer = new memoizer();
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = hamstersMemoizer;
	}

/***/ })
/******/ ]);
//# sourceMappingURL=hamsters.min.js.map