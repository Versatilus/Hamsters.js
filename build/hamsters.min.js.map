{"version":3,"sources":["webpack:///hamsters.min.js","webpack:///webpack/bootstrap e5259069e243032781d5","webpack:///./src/core.js","webpack:///./~/node-libs-browser/~/process/browser.js"],"names":["hamsters","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","process","global","_classCallCheck","instance","Constructor","TypeError","_typeof","Symbol","iterator","obj","constructor","prototype","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","this","version","maxThreads","determineGlobalMaxThreads","debug","persistence","memoize","atomics","legacy","tools","randomArray","aggregateArrays","aggregateThreadOutputs","splitArrays","splitArrayIntoSubArrays","habitat","browser","isBrowser","worker","isWorker","node","isNode","reactNative","isReactNative","shell","isShell","transferrable","supportsTransferrableObjects","isLegacyEnvironment","supportsAtomicOperations","pool","uri","tasks","errors","threads","running","pending","run","runHamster","loop","loopAbstraction","parseJson","parseJsonOnThread","stringifyJson","stringifyJsonOnThread","init","initializeLibrary","value","window","importScripts","Uint8Array","Worker","SharedArrayBuffer","startOptions","processStartOptions","setupBrowserSupport","SharedWorker","setupWorkerSupport","wheel","legacyHamsterWheel","hamsterWheel","spawnHamsters","chewGarbage","RegExp","isNaN","test","navigator","userAgent","max","hardwareConcurrency","toLowerCase","indexOf","isIE","workerBlob","generateWorkerBlob","e","hasOwnProperty","URL","createObjectURL","createBlob","String","giveHamsterWork","push","spawnHamster","ie10","workerWorker","textContent","Blob","BlobMaker","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","blob","append","type","getBlob","self","addEventListener","port","ports","start","params","data","rtn","dataType","fn","eval","postMessage","results","typedArrayFromBuffer","buffer","types","uint32","Uint32Array","uint16","Uint16Array","uint8","uint8clamped","Uint8ClampedArray","int32","Int32Array","int16","Int16Array","int8","Int8Array","float32","Float32Array","float64","Float64Array","onmessage","Function","taskid","workers","order","cb","count","input","output","onSuccess","inputArray","hamsterFood","aggregate","task","thread_id","hamster","trackThread","trackInput","legacyProcessor","clean","getOutput","cache","poolThread","trainHamster","array","feedHamster","console","info","Date","getTime","n","threadArrays","size","Math","ceil","slice","subarray","prepareFunction","operator","startIndex","limit","incrementBy","functionBody","startingIndex","endingIndex","substring","string","JSON","parse","json","stringify","newTask","result","checkCache","setTimeout","work","round","random","reduce","a","b","concat","len","bufferLength","processDataType","offset","set","cachedResult","arr","Array","sort","reverse","workArray","food","workerid","agg","success","item","splice","libraryContext","timeStamp","processQueue","shift","terminate","onerror","msg","lineno","filename","message","error","processData","buffers","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","Item","noop","nextTick","args","arguments","apply","title","env","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"hamsters.min.js","sourcesContent":["var hamsters =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/*\n\t* Title: this.js\n\t* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers\n\t* Author: Austin K. Smith\n\t* Contact: austin@asmithdev.com\n\t* Copyright: 2015 Austin K. Smith - austin@asmithdev.com\n\t* License: Artistic License 2.0\n\t*/\n\t\n\t/* jshint esversion: 6 */\n\t\n\tvar hamsters = function () {\n\t  function hamsters() {\n\t    'use strict';\n\t\n\t    _classCallCheck(this, hamsters);\n\t\n\t    this.version = '4.2.2';\n\t    this.maxThreads = this.determineGlobalMaxThreads();\n\t    this.debug = false;\n\t    this.persistence = true;\n\t    this.memoize = false;\n\t    this.atomics = false;\n\t    this.legacy = false;\n\t    this.tools = {\n\t      randomArray: this.randomArray,\n\t      aggregateArrays: this.aggregateThreadOutputs,\n\t      splitArrays: this.splitArrayIntoSubArrays\n\t    };\n\t    this.habitat = {\n\t      browser: this.isBrowser(),\n\t      worker: this.isWorker(),\n\t      node: this.isNode(),\n\t      reactNative: this.isReactNative(),\n\t      shell: this.isShell(),\n\t      transferrable: this.supportsTransferrableObjects(),\n\t      legacy: this.isLegacyEnvironment(),\n\t      atomics: this.supportsAtomicOperations()\n\t    };\n\t    this.pool = {\n\t      uri: null,\n\t      tasks: [],\n\t      errors: [],\n\t      threads: [],\n\t      running: [],\n\t      pending: []\n\t    };\n\t    this.run = this.runHamster;\n\t    this.loop = this.loopAbstraction;\n\t    this.parseJson = this.parseJsonOnThread, this.stringifyJson = this.stringifyJsonOnThread, this.init = this.initializeLibrary;\n\t  }\n\t\n\t  _createClass(hamsters, [{\n\t    key: 'isBrowser',\n\t    value: function isBrowser() {\n\t      return (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === \"object\";\n\t    }\n\t  }, {\n\t    key: 'isNode',\n\t    value: function isNode() {\n\t      return (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === \"object\" && \"function\" === \"function\" && !this.isBrowser() && !this.isWorker();\n\t    }\n\t  }, {\n\t    key: 'isWorker',\n\t    value: function isWorker() {\n\t      return typeof importScripts === \"function\";\n\t    }\n\t  }, {\n\t    key: 'isReactNative',\n\t    value: function isReactNative() {\n\t      return !this.isNode() && (typeof global === 'undefined' ? 'undefined' : _typeof(global)) === 'object';\n\t    }\n\t  }, {\n\t    key: 'isShell',\n\t    value: function isShell() {\n\t      return this.isBrowser() && !this.isNode() && !this.isWorker() && !this.isReactNative();\n\t    }\n\t  }, {\n\t    key: 'supportsTransferrableObjects',\n\t    value: function supportsTransferrableObjects() {\n\t      return typeof Uint8Array !== 'undefined';\n\t    }\n\t  }, {\n\t    key: 'isLegacyEnvironment',\n\t    value: function isLegacyEnvironment() {\n\t      return this.isShell() || typeof Worker === 'undefined';\n\t    }\n\t  }, {\n\t    key: 'supportsAtomicOperations',\n\t    value: function supportsAtomicOperations() {\n\t      return typeof SharedArrayBuffer !== 'undefined';\n\t    }\n\t  }, {\n\t    key: 'initializeLibrary',\n\t    value: function initializeLibrary(startOptions) {\n\t      if (typeof startOptions !== 'undefined') {\n\t        this.processStartOptions(startOptions);\n\t      }\n\t      if (this.habitat.browser && !this.habitat.reactNative) {\n\t        this.setupBrowserSupport();\n\t      }\n\t      if (this.habitat.worker && typeof SharedWorker !== 'undefined') {\n\t        this.setupWorkerSupport();\n\t      }\n\t      if (this.habitat.node || this.habitat.reactNative) {\n\t        if (typeof this.Worker !== 'undefined') {\n\t          global.Worker = this.Worker;\n\t        }\n\t      }\n\t      if (this.habitat.legacy) {\n\t        this.wheel = this.legacyHamsterWheel;\n\t      } else {\n\t        this.wheel = this.hamsterWheel;\n\t        this.spawnHamsters();\n\t      }\n\t      this.chewGarbage(startOptions);\n\t    }\n\t  }, {\n\t    key: 'isIE',\n\t    value: function isIE(version) {\n\t      return new RegExp('msie' + (!isNaN(version) ? '\\\\s' + version : ''), 'i').test(navigator.userAgent);\n\t    }\n\t  }, {\n\t    key: 'determineGlobalMaxThreads',\n\t    value: function determineGlobalMaxThreads() {\n\t      // Default to global thread count of 4\n\t      var max = 4;\n\t      // Detect logical core count on machine\n\t      if (typeof navigator !== 'undefined' && typeof navigator.hardwareConcurrency !== 'undefined') {\n\t        max = navigator.hardwareConcurrency;\n\t      }\n\t      // Firefox per origin limit is 20\n\t      if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && max > 20) {\n\t        max = 20;\n\t      }\n\t      // Got it\n\t      return max;\n\t    }\n\t  }, {\n\t    key: 'setupBrowserSupport',\n\t    value: function setupBrowserSupport() {\n\t      if (typeof Worker === 'undefined' || ['Kindle/3.0', 'Mobile/8F190', 'IEMobile'].indexOf(navigator.userAgent) !== -1 || this.isIE(10)) {\n\t        this.habitat.legacy = true;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'setupWorkerSupport',\n\t    value: function setupWorkerSupport() {\n\t      try {\n\t        var workerBlob = this.generateWorkerBlob();\n\t        var SharedHamster = new SharedWorker(workerBlob, 'SharedHamsterWheel');\n\t        this.pool.uri = workerBlob;\n\t      } catch (e) {\n\t        this.habitat.legacy = true;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'processStartOptions',\n\t    value: function processStartOptions(startOptions) {\n\t      for (var key in startOptions) {\n\t        if (startOptions.hasOwnProperty(key)) {\n\t          hamsters[key] = startOptions[key];\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: 'generateWorkerBlob',\n\t    value: function generateWorkerBlob() {\n\t      return URL.createObjectURL(this.createBlob('(' + String(this.giveHamsterWork()) + ')();'));\n\t    }\n\t  }, {\n\t    key: 'spawnHamsters',\n\t    value: function spawnHamsters() {\n\t      if (this.habitat.browser) {\n\t        this.pool.uri = this.generateWorkerBlob();\n\t      }\n\t      if (this.persistence) {\n\t        var i = this.maxThreads;\n\t        for (i; i > 0; i--) {\n\t          this.pool.threads.push(this.spawnHamster());\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: 'spawnHamster',\n\t    value: function spawnHamster() {\n\t      if (this.habitat.ie10) {\n\t        return new Worker('src/common/wheel.min.js');\n\t      } else if (this.habitat.worker) {\n\t        return new SharedWorker(this.pool.uri, 'SharedHamsterWheel');\n\t      } else if (this.habitat.node) {\n\t        return new Worker(this.giveHamsterWork());\n\t      } else {\n\t        return new Worker(this.pool.uri);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'giveHamsterWork',\n\t    value: function giveHamsterWork() {\n\t      if (this.habitat.worker) {\n\t        return this.workerWorker;\n\t      }\n\t      return this.worker;\n\t    }\n\t  }, {\n\t    key: 'createBlob',\n\t    value: function createBlob(textContent) {\n\t      if (!Blob) {\n\t        var BlobMaker = BlobBuilder || WebKitBlobBuilder || MozBlobBuilder || MSBlobBuilder;\n\t        var blob = new BlobMaker();\n\t        blob.append([textContent], {\n\t          type: 'application/javascript'\n\t        });\n\t        return blob.getBlob();\n\t      }\n\t      return new Blob([textContent], {\n\t        type: 'application/javascript'\n\t      });\n\t    }\n\t  }, {\n\t    key: 'workerWorker',\n\t    value: function workerWorker() {\n\t      self.addEventListener(\"connect\", function (e) {\n\t        var port = e.ports[0];\n\t        port.start();\n\t        port.addEventListener(\"message\", function (e) {\n\t          self.params = e.data;\n\t          self.rtn = {\n\t            data: [],\n\t            dataType: params.dataType\n\t          };\n\t          var fn = eval(\"(\" + params.fn + \")\");\n\t          if (fn) {\n\t            fn();\n\t          }\n\t          port.postMessage({\n\t            results: rtn\n\t          });\n\t        }, false);\n\t      }, false);\n\t    }\n\t  }, {\n\t    key: 'worker',\n\t    value: function worker() {\n\t      self.typedArrayFromBuffer = function (dataType, buffer) {\n\t        var types = {\n\t          'uint32': Uint32Array,\n\t          'uint16': Uint16Array,\n\t          'uint8': Uint8Array,\n\t          'uint8clamped': Uint8ClampedArray,\n\t          'int32': Int32Array,\n\t          'int16': Int16Array,\n\t          'int8': Int8Array,\n\t          'float32': Float32Array,\n\t          'float64': Float64Array\n\t        };\n\t        if (!types[dataType]) {\n\t          return buffer;\n\t        }\n\t        return new types[dataType](buffer);\n\t      };\n\t\n\t      self.onmessage = function (e) {\n\t        self.params = e.data;\n\t        self.rtn = {\n\t          data: [],\n\t          dataType: params.dataType\n\t        };\n\t        var fn = new Function(params.fn);\n\t        if (fn) {\n\t          fn();\n\t        }\n\t        if (params.dataType) {\n\t          rtn.data = self.typedArrayFromBuffer(params.dataType, rtn.data);\n\t          postMessage({\n\t            results: rtn\n\t          }, [rtn.data.buffer]);\n\t        } else {\n\t          postMessage({\n\t            results: rtn\n\t          });\n\t        }\n\t      };\n\t    }\n\t  }, {\n\t    key: 'newTask',\n\t    value: function newTask(taskid, workers, order, dataType, fn, cb) {\n\t      this.pool.tasks.push({\n\t        id: taskid,\n\t        workers: [],\n\t        count: 0,\n\t        threads: workers,\n\t        input: [],\n\t        dataType: dataType || null,\n\t        fn: fn,\n\t        output: [],\n\t        order: order || null,\n\t        onSuccess: cb\n\t      });\n\t      return this.pool.tasks[taskid];\n\t    }\n\t  }, {\n\t    key: 'legacyHamsterWheel',\n\t    value: function legacyHamsterWheel(inputArray, hamsterFood, aggregate, onSuccess, task, thread_id, hamster, memoize) {\n\t      this.trackThread(task, this.pool.running, thread_id);\n\t      if (memoize || this.debug) {\n\t        this.trackInput(inputArray, thread_id, task, hamsterFood);\n\t      }\n\t      legacyProcessor(hamsterFood, inputArray, function (output) {\n\t        this.clean(task, thread_id);\n\t        task.output[thread_id] = output.data;\n\t        if (task.workers.length === 0 && task.count === task.threads) {\n\t          onSuccess(getOutput(task.output, aggregate, output.dataType));\n\t          this.pool.tasks[task.id] = null;\n\t          if (this.cache && memoize !== false) {\n\t            memoize(task.fn, task.input, output.data, output.dataType);\n\t          }\n\t        }\n\t      });\n\t      task.count += 1; //Thread finished\n\t    }\n\t  }, {\n\t    key: 'hamsterWheel',\n\t    value: function hamsterWheel(inputArray, hamsterFood, aggregate, onSuccess, task, thread_id, hamster, memoize) {\n\t      if (this.maxThreads === this.pool.running.length) {\n\t        this.poolThread(inputArray, hamsterFood, thread_id, onSuccess, task, aggregate, memoize);\n\t        return;\n\t      }\n\t      if (memoize || this.debug) {\n\t        this.trackInput(inputArray, thread_id, task, hamsterFood);\n\t      }\n\t      if (!hamster) {\n\t        if (this.persistence) {\n\t          hamster = this.pool.threads[this.pool.running.length];\n\t        } else {\n\t          hamster = spawnHamster();\n\t        }\n\t      }\n\t      this.trainHamster(thread_id, aggregate, onSuccess, task, hamster, memoize);\n\t      this.trackThread(task, this.pool.running, thread_id);\n\t      hamsterFood.array = inputArray;\n\t      this.feedHamster(hamster, hamsterFood);\n\t      task.count += 1; //Increment count, thread is running\n\t      if (this.debug === 'verbose') {\n\t        console.info('Spawning Hamster #' + thread_id + ' @ ' + new Date().getTime());\n\t      }\n\t    }\n\t  }, {\n\t    key: 'chewGarbage',\n\t    value: function chewGarbage(startOptions) {\n\t      delete this.init;\n\t      startOptions = null;\n\t    }\n\t  }, {\n\t    key: 'splitArrayIntoSubArrays',\n\t    value: function splitArrayIntoSubArrays(array, n) {\n\t      var i = 0;\n\t      var threadArrays = [];\n\t      var size = Math.ceil(array.length / n);\n\t      if (array.slice) {\n\t        while (i < array.length) {\n\t          threadArrays.push(array.slice(i, i += size));\n\t        }\n\t      } else {\n\t        while (i < array.length) {\n\t          threadArrays.push(array.subarray(i, i += size));\n\t        }\n\t      }\n\t      return threadArrays;\n\t    }\n\t  }, {\n\t    key: 'loopAbstraction',\n\t    value: function loopAbstraction(input, onSuccess) {\n\t      var params = {\n\t        run: this.prepareFunction(input.operator),\n\t        init: input.startIndex || 0,\n\t        limit: input.limit,\n\t        array: input.array,\n\t        incrementBy: input.incrementBy || 1,\n\t        dataType: input.dataType || null,\n\t        worker: this.habitat.worker\n\t      };\n\t      this.runHamster(params, function () {\n\t        var operator = params.run;\n\t        if (typeof operator === \"string\") {\n\t          if (params.worker) {\n\t            operator = eval(\"(\" + operator + \")\");\n\t          } else {\n\t            operator = new Function(operator);\n\t          }\n\t        }\n\t        if (!params.limit) {\n\t          params.limit = params.array.length;\n\t        }\n\t        var i = params.init;\n\t        for (i; i < params.limit; i += params.incrementBy) {\n\t          rtn.data[i] = operator(params.array[i]);\n\t        }\n\t      }, function (rtn) {\n\t        onSuccess(rtn);\n\t      }, input.threads, 1, input.dataType);\n\t    }\n\t  }, {\n\t    key: 'prepareFunction',\n\t    value: function prepareFunction(functionBody) {\n\t      if (!this.habitat.legacy) {\n\t        functionBody = String(functionBody);\n\t        if (!this.habitat.worker) {\n\t          var startingIndex = functionBody.indexOf(\"{\") + 1;\n\t          var endingIndex = functionBody.length - 1;\n\t          return functionBody.substring(startingIndex, endingIndex);\n\t        }\n\t      }\n\t      return functionBody;\n\t    }\n\t  }, {\n\t    key: 'parseJsonOnThread',\n\t    value: function parseJsonOnThread(string, onSuccess) {\n\t      this.runHamster({ input: string }, function () {\n\t        rtn.data = JSON.parse(params.input);\n\t      }, function (output) {\n\t        onSuccess(output[0]);\n\t      }, 1);\n\t    }\n\t  }, {\n\t    key: 'stringifyJsonOnThread',\n\t    value: function stringifyJsonOnThread(json, onSuccess) {\n\t      this.runHamster({ input: json }, function () {\n\t        rtn.data = JSON.stringify(params.input);\n\t      }, function (output) {\n\t        onSuccess(output[0]);\n\t      }, 1);\n\t    }\n\t  }, {\n\t    key: 'runHamster',\n\t    value: function runHamster(params, fn, onSuccess, workers, aggregate, dataType, memoize, order) {\n\t      if (!params || !fn) {\n\t        return 'Error processing for loop, missing params or function';\n\t      }\n\t      workers = this.habitat.legacy ? 1 : workers || 1;\n\t      if (dataType) {\n\t        dataType = dataType.toLowerCase();\n\t      }\n\t      var task = this.newTask(this.pool.tasks.length, workers, order, dataType, fn, onSuccess);\n\t      if (this.cache && memoize) {\n\t        var result = checkCache(fn, task.input, dataType);\n\t        if (result && onSuccess) {\n\t          setTimeout(function () {\n\t            this.pool.tasks[taskid] = null; //Clean up our task, not needed any longer\n\t            onSuccess(result);\n\t          }, 4);\n\t          return;\n\t        }\n\t      }\n\t      this.work(task, params, fn, onSuccess, aggregate, dataType, memoize, order);\n\t    }\n\t  }, {\n\t    key: 'randomArray',\n\t    value: function randomArray(count, onSuccess) {\n\t      var randomArray = [];\n\t      while (count > 0) {\n\t        randomArray.push(Math.round(Math.random() * (100 - 1) + 1));\n\t        count -= 1;\n\t      }\n\t      onSuccess(randomArray);\n\t    }\n\t  }, {\n\t    key: 'aggregateThreadOutputs',\n\t    value: function aggregateThreadOutputs(input, dataType) {\n\t      if (!dataType || !this.habitat.transferrable) {\n\t        return input.reduce(function (a, b) {\n\t          return a.concat(b);\n\t        });\n\t      }\n\t      var i = 0;\n\t      var len = input.length;\n\t      var bufferLength = 0;\n\t      for (i; i < len; i += 1) {\n\t        bufferLength += input[i].length;\n\t      }\n\t      var output = this.processDataType(dataType, bufferLength);\n\t      var offset = 0;\n\t      for (i = 0; i < len; i += 1) {\n\t        output.set(input[i], offset);\n\t        offset += input[i].length;\n\t      }\n\t      return output;\n\t    }\n\t  }, {\n\t    key: 'checkCache',\n\t    value: function checkCache(fn, input, dataType) {\n\t      var cachedResult = this.cache[fn];\n\t      if (cachedResult) {\n\t        if (cachedResult[0] === input && cachedResult[2] === dataType) {\n\t          return cachedResult;\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: 'memoize',\n\t    value: function memoize(fn, inputArray, output, dataType) {\n\t      this.cache[fn] = [inputArray, output, dataType];\n\t    }\n\t  }, {\n\t    key: 'sort',\n\t    value: function sort(arr, order) {\n\t      switch (order) {\n\t        case 'desc':\n\t        case 'asc':\n\t          return Array.prototype.sort.call(arr, function (a, b) {\n\t            return order === 'asc' ? a - b : b - a;\n\t          });\n\t        case 'ascAlpha':\n\t          return arr.sort();\n\t        case 'descAlpha':\n\t          return arr.reverse();\n\t        default:\n\t          return arr;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'work',\n\t    value: function work(task, params, fn, onSuccess, aggregate, dataType, memoize, order) {\n\t      var workArray = params.array;\n\t      if (workArray && task.threads !== 1) {\n\t        workArray = this.splitArrayIntoSubArrays(workArray, task.threads); //Divide our array into equal array sizes\n\t      }\n\t      var food = {};\n\t      var key = void 0;\n\t      for (key in params) {\n\t        if (params.hasOwnProperty(key) && key !== 'array') {\n\t          food[key] = params[key];\n\t        }\n\t      }\n\t      food.fn = this.prepareFunction(fn);\n\t      food.dataType = dataType;\n\t      var i = 0;\n\t      while (i < task.threads) {\n\t        if (workArray && task.threads !== 1) {\n\t          this.wheel(workArray[i], food, aggregate, onSuccess, task, task.count, null, memoize);\n\t        } else {\n\t          this.wheel(workArray, food, aggregate, onSuccess, task, task.count, null, memoize);\n\t        }\n\t        i += 1;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'assignOutput',\n\t    value: function assignOutput(task, inputArray) {\n\t      if (!task || !inputArray || !this.habitat.atomics) {\n\t        return;\n\t      }\n\t      task.output = new SharedArrayBuffer(inputArray.length);\n\t    }\n\t  }, {\n\t    key: 'trackInput',\n\t    value: function trackInput(inputArray, thread_id, task, hamsterFood) {\n\t      task.input.push({\n\t        input: inputArray,\n\t        workerid: thread_id,\n\t        taskid: task.id,\n\t        params: hamsterFood,\n\t        start: new Date().getTime()\n\t      });\n\t    }\n\t  }, {\n\t    key: 'trackThread',\n\t    value: function trackThread(task, running, id) {\n\t      task.workers.push(id); //Keep track of threads scoped to current task\n\t      this.pool.running.push(id); //Keep track of all currently running threads\n\t    }\n\t  }, {\n\t    key: 'poolThread',\n\t    value: function poolThread(inputArray, hamsterFood, thread_id, cb, task, agg, memoize) {\n\t      this.pool.pending.push({\n\t        memoize: memoize,\n\t        input: inputArray,\n\t        params: hamsterFood,\n\t        workerid: thread_id,\n\t        onSuccess: cb,\n\t        task: task,\n\t        aggregate: agg\n\t      });\n\t    }\n\t  }, {\n\t    key: 'legacyProcessor',\n\t    value: function legacyProcessor(params, inputArray, onSuccess) {\n\t      setTimeout(function () {\n\t        var rtn = {\n\t          success: true,\n\t          data: []\n\t        };\n\t        var params = params;\n\t        params.array = inputArray;\n\t        params.fn();\n\t        if (params.dataType && params.dataType != \"na\") {\n\t          rtn.data = this.processDataType(params.dataType, rtn.data);\n\t          rtn.dataType = params.dataType;\n\t        }\n\t        onSuccess(rtn);\n\t      }, 4); //4ms delay (HTML5 spec minimum), simulate threading\n\t    }\n\t  }, {\n\t    key: 'getOutput',\n\t    value: function getOutput(output, aggregate, dataType) {\n\t      if (aggregate && output.length <= 20) {\n\t        return this.aggregateThreadOutputs(output, dataType);\n\t      }\n\t      return output;\n\t    }\n\t  }, {\n\t    key: 'processQueue',\n\t    value: function processQueue(hamster, item) {\n\t      if (!item) {\n\t        return;\n\t      }\n\t      this.wheel(item.input, item.params, item.aggregate, item.onSuccess, item.task, item.workerid, hamster, item.memoize); //Assign most recently finished thread to queue item\n\t    }\n\t  }, {\n\t    key: 'clean',\n\t    value: function clean(task, id) {\n\t      this.pool.running.splice(this.pool.running.indexOf(id), 1); //Remove thread from running pool\n\t      task.workers.splice(task.workers.indexOf(id), 1); //Remove thread from task running pool\n\t    }\n\t  }, {\n\t    key: 'trainHamster',\n\t    value: function trainHamster(id, aggregate, onSuccess, task, hamster, memoize) {\n\t      var libraryContext = this;\n\t      var onmessage = function onmessage(e, results) {\n\t        libraryContext.clean(task, id);\n\t        results = e.data.results;\n\t        task.output[id] = results.data;\n\t        if (this.debug === 'verbose') {\n\t          console.info('Hamster #' + id + ' finished ' + '@ ' + e.timeStamp);\n\t        }\n\t        if (task.workers.length === 0 && task.count === task.threads) {\n\t          var output = libraryContext.getOutput(task.output, aggregate, task.dataType);\n\t          if (task.order) {\n\t            onSuccess(sort(output, task.order));\n\t          } else {\n\t            onSuccess(output);\n\t          }\n\t          if (this.debug) {\n\t            console.info('Execution Complete! Elapsed: ' + (e.timeStamp - task.input[0].start) / 1000 + 's');\n\t          }\n\t          libraryContext.pool.tasks[task.id] = null; //Clean up our task, not needed any longer\n\t          // if(this.cache && memoize) {\n\t          //   if(task.output[id] && !task.output[id].slice) {\n\t          //     memoize(task.fn, task.input[0].input, normalizeArray(output), results.dataType);\n\t          //   } else {\n\t          //     memoize(task.fn, task.input[0].input, getOutput(task.output, aggregate, results.dataType), results.dataType);\n\t          //   }\n\t          // }\n\t        }\n\t        if (libraryContext.pool.pending.length !== 0) {\n\t          libraryContext.processQueue(hamster, libraryContext.pool.pending.shift());\n\t        } else if (!libraryContext.persistence && !libraryContext.habitat.worker) {\n\t          hamster.terminate(); //Kill the thread only if no items waiting to run (20-22% performance improvement observed during testing, repurposing threads vs recreating them)\n\t        }\n\t      };\n\t\n\t      var onerror = function onerror(e) {\n\t        if (!libraryContext.habitat.worker) {\n\t          hamster.terminate(); //Kill the thread\n\t        }\n\t        libraryContext.pool.errors.push({\n\t          msg: 'Error Hamster #' + id + ': Line ' + e.lineno + ' in ' + e.filename + ': ' + e.message\n\t        });\n\t        console.error('Error Hamster #' + id + ': Line ' + e.lineno + ' in ' + e.filename + ': ' + e.message);\n\t      };\n\t\n\t      if (this.habitat.worker) {\n\t        hamster.port.onmessage = onmessage;\n\t        hamster.port.onerror = onerror;\n\t      } else {\n\t        hamster.onmessage = onmessage;\n\t        hamster.onerror = onerror;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'processData',\n\t    value: function processData(dataType, buffer) {\n\t      var types = {\n\t        'uint32': Uint32Array,\n\t        'uint16': Uint16Array,\n\t        'uint8': Uint8Array,\n\t        'uint8clamped': Uint8ClampedArray,\n\t        'int32': Int32Array,\n\t        'int16': Int16Array,\n\t        'int8': Int8Array,\n\t        'float32': Float32Array,\n\t        'float64': Float64Array\n\t      };\n\t      if (!types[dataType]) {\n\t        return dataType;\n\t      }\n\t      return new types[dataType](buffer);\n\t    }\n\t  }, {\n\t    key: 'processDataType',\n\t    value: function processDataType(dataType, buffer) {\n\t      if (this.habitat.transferrable) {\n\t        return this.processData(dataType, buffer);\n\t      }\n\t      return buffer;\n\t    }\n\t  }, {\n\t    key: 'feedHamster',\n\t    value: function feedHamster(hamster, food) {\n\t      if (this.habitat.worker) {\n\t        return hamster.port.postMessage(food);\n\t      }\n\t      if (this.habitat.ie10) {\n\t        return hamster.postMessage(food);\n\t      }\n\t      var buffers = [],\n\t          key = void 0;\n\t      for (key in food) {\n\t        if (food.hasOwnProperty(key) && food[key] && food[key].buffer) {\n\t          buffers.push(food[key].buffer);\n\t        }\n\t      }\n\t      return hamster.postMessage(food, buffers);\n\t    }\n\t  }]);\n\t\n\t  return hamsters;\n\t}();\n\t\n\tmodule.exports = new hamsters();\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), (function() { return this; }())))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\tprocess.prependListener = noop;\n\tprocess.prependOnceListener = noop;\n\t\n\tprocess.listeners = function (name) { return [] }\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// hamsters.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e5259069e243032781d5","/*\n* Title: this.js\n* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers\n* Author: Austin K. Smith\n* Contact: austin@asmithdev.com\n* Copyright: 2015 Austin K. Smith - austin@asmithdev.com\n* License: Artistic License 2.0\n*/\n\n/* jshint esversion: 6 */\n\n\nclass hamsters {\n   constructor() {\n    'use strict';\n\n    this.version = '4.2.2';\n    this.maxThreads = this.determineGlobalMaxThreads();\n    this.debug = false;\n    this.persistence = true;\n    this.memoize = false;\n    this.atomics = false;\n    this.legacy = false;\n    this.tools = {\n      randomArray: this.randomArray,\n      aggregateArrays: this.aggregateThreadOutputs,\n      splitArrays: this.splitArrayIntoSubArrays\n    };\n    this.habitat = {\n      browser: this.isBrowser(),\n      worker: this.isWorker(),\n      node: this.isNode(),\n      reactNative: this.isReactNative(),\n      shell: this.isShell(),\n      transferrable: this.supportsTransferrableObjects(),\n      legacy: this.isLegacyEnvironment(),\n      atomics: this.supportsAtomicOperations()\n    };\n    this.pool = {\n      uri: null,\n      tasks: [],\n      errors: [],\n      threads: [],\n      running: [],\n      pending: []\n    };\n    this.run = this.runHamster;\n    this.loop = this.loopAbstraction;\n    this.parseJson = this.parseJsonOnThread,\n    this.stringifyJson = this.stringifyJsonOnThread,\n    this.init = this.initializeLibrary;\n  }\n\n  isBrowser() {\n    return typeof window === \"object\";\n  }\n\n  isNode() {\n    return typeof process === \"object\" && typeof require === \"function\" && !this.isBrowser() && !this.isWorker();\n  }\n\n  isWorker() {\n    return typeof importScripts === \"function\";\n  }\n\n  isReactNative() {\n    return !this.isNode() && typeof global === 'object';\n  }\n\n  isShell() {\n    return this.isBrowser() && !this.isNode() && !this.isWorker() && !this.isReactNative()\n  }\n\n  supportsTransferrableObjects() {\n    return typeof Uint8Array !== 'undefined';\n  }\n\n  isLegacyEnvironment() {\n    return (this.isShell() || typeof Worker === 'undefined');\n  }\n\n  supportsAtomicOperations() {\n    return typeof SharedArrayBuffer !== 'undefined';\n  }\n\n\n  initializeLibrary(startOptions) {\n    if(typeof startOptions !== 'undefined') {\n      this.processStartOptions(startOptions);\n    }\n    if(this.habitat.browser && !this.habitat.reactNative) {\n      this.setupBrowserSupport();\n    }\n    if(this.habitat.worker && typeof SharedWorker !== 'undefined') {\n      this.setupWorkerSupport();\n    }\n    if(this.habitat.node || this.habitat.reactNative) {\n      if(typeof this.Worker !== 'undefined') {\n        global.Worker = this.Worker;\n      }\n    }\n    if(this.habitat.legacy) {\n      this.wheel = this.legacyHamsterWheel;\n    } else {\n      this.wheel = this.hamsterWheel;\n      this.spawnHamsters();\n    }\n    this.chewGarbage(startOptions);\n  }\n\n  isIE(version) {\n    return (new RegExp('msie' + (!isNaN(version) ? ('\\\\s'+version) : ''), 'i').test(navigator.userAgent));\n  }\n\n  determineGlobalMaxThreads() {\n    // Default to global thread count of 4\n    let max = 4;\n    // Detect logical core count on machine\n    if(typeof navigator !== 'undefined' && typeof navigator.hardwareConcurrency !== 'undefined') {\n      max = navigator.hardwareConcurrency;\n    }\n    // Firefox per origin limit is 20\n    if(navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && max > 20) {\n      max = 20;\n    }\n    // Got it\n    return max;\n  }\n\n\n  setupBrowserSupport() {\n    if(typeof Worker === 'undefined' || ['Kindle/3.0', 'Mobile/8F190', 'IEMobile'].indexOf(navigator.userAgent) !== -1 || this.isIE(10)) {\n      this.habitat.legacy = true;\n    }\n  }\n\n  setupWorkerSupport() {\n    try {\n      let workerBlob = this.generateWorkerBlob();\n      let SharedHamster = new SharedWorker(workerBlob, 'SharedHamsterWheel');\n      this.pool.uri = workerBlob;\n    } catch(e) {\n      this.habitat.legacy = true;\n    }\n  }\n\n  processStartOptions(startOptions) {\n    for(var key in startOptions) {\n      if(startOptions.hasOwnProperty(key)) {\n        hamsters[key] = startOptions[key];\n      }\n    }\n  }\n\n  generateWorkerBlob() {\n    return URL.createObjectURL(this.createBlob('(' + String(this.giveHamsterWork()) + ')();'));\n  }\n\n  spawnHamsters() {\n    if(this.habitat.browser) {\n      this.pool.uri = this.generateWorkerBlob();\n    }\n    if(this.persistence) {\n      let i = this.maxThreads;\n      for (i; i > 0; i--) {\n        this.pool.threads.push(this.spawnHamster());\n      }\n    }\n  }\n\n  spawnHamster() {\n    if(this.habitat.ie10) {\n      return new Worker('src/common/wheel.min.js');\n    } else if(this.habitat.worker) {\n      return new SharedWorker(this.pool.uri, 'SharedHamsterWheel');\n    } else if (this.habitat.node) {\n      return new Worker(this.giveHamsterWork());\n    } else {\n      return new Worker(this.pool.uri);\n    }\n  }\n\n  giveHamsterWork() {\n    if(this.habitat.worker) {\n      return this.workerWorker;\n    }\n    return this.worker;\n  }\n\n  createBlob(textContent) {\n    if(!Blob) {\n      let BlobMaker = (BlobBuilder || WebKitBlobBuilder || MozBlobBuilder || MSBlobBuilder);\n      let blob = new BlobMaker();\n      blob.append([textContent], {\n        type: 'application/javascript'\n      });\n      return blob.getBlob();\n    } \n    return new Blob([textContent], {\n      type: 'application/javascript'\n    });\n  }\n\n  workerWorker() {\n    self.addEventListener(\"connect\", function(e) {\n      const port = e.ports[0];\n      port.start();\n      port.addEventListener(\"message\", function(e) {\n        self.params = e.data;\n        self.rtn = {\n          data: [],\n          dataType: params.dataType\n        };\n        let fn = eval(\"(\" + params.fn + \")\");\n        if (fn) {\n          fn();\n        }\n        port.postMessage({\n          results: rtn\n        });\n      }, false);\n    }, false);\n  }\n\n  worker() {\n    self.typedArrayFromBuffer = function(dataType, buffer) {\n      const types = {\n        'uint32': Uint32Array,\n        'uint16': Uint16Array,\n        'uint8': Uint8Array,\n        'uint8clamped': Uint8ClampedArray,\n        'int32': Int32Array,\n        'int16': Int16Array,\n        'int8': Int8Array,\n        'float32': Float32Array,\n        'float64': Float64Array\n      };\n      if(!types[dataType]) {\n        return buffer;\n      }\n      return new types[dataType](buffer);\n    };\n\n    self.onmessage = function(e) {\n      self.params = e.data;\n      self.rtn = {\n        data: [],\n        dataType: params.dataType\n      };\n      let fn = new Function(params.fn);\n      if(fn) {\n        fn();\n      }\n      if(params.dataType) {\n        rtn.data = self.typedArrayFromBuffer(params.dataType, rtn.data);\n        postMessage({\n          results: rtn\n        }, [rtn.data.buffer]);\n      } else {\n        postMessage({\n          results: rtn\n        });\n      }\n    };\n  }\n\n  newTask(taskid, workers, order, dataType, fn, cb) {\n    this.pool.tasks.push({\n      id: taskid,\n      workers: [],\n      count: 0,\n      threads: workers, \n      input: [],\n      dataType: dataType || null,\n      fn: fn,\n      output: [], \n      order: order || null,\n      onSuccess: cb\n    });\n    return this.pool.tasks[taskid];\n  }\n\n  legacyHamsterWheel(inputArray, hamsterFood, aggregate, onSuccess, task, thread_id, hamster, memoize) {\n    this.trackThread(task, this.pool.running, thread_id);\n    if(memoize || this.debug) {\n      this.trackInput(inputArray, thread_id, task, hamsterFood);\n    }\n    legacyProcessor(hamsterFood, inputArray, function(output) {\n      this.clean(task, thread_id);\n      task.output[thread_id] = output.data;\n      if(task.workers.length === 0 && task.count === task.threads) {\n        onSuccess(getOutput(task.output, aggregate, output.dataType));\n        this.pool.tasks[task.id] = null;\n        if(this.cache && memoize !== false) {\n          memoize(task.fn, task.input, output.data, output.dataType);\n        }\n      }\n    });\n    task.count += 1; //Thread finished\n  }\n\n  hamsterWheel(inputArray, hamsterFood, aggregate, onSuccess, task, thread_id, hamster, memoize) {\n    if(this.maxThreads === this.pool.running.length) {\n      this.poolThread(inputArray, hamsterFood, thread_id, onSuccess, task, aggregate, memoize);\n      return;\n    }\n    if(memoize || this.debug) {\n      this.trackInput(inputArray, thread_id, task, hamsterFood);\n    }\n    if(!hamster) {\n      if(this.persistence) {\n        hamster = this.pool.threads[this.pool.running.length];\n      } else {\n        hamster = spawnHamster();\n      }\n    }\n    this.trainHamster(thread_id, aggregate, onSuccess, task, hamster, memoize);\n    this.trackThread(task, this.pool.running, thread_id);\n    hamsterFood.array = inputArray;\n    this.feedHamster(hamster, hamsterFood);\n    task.count += 1; //Increment count, thread is running\n    if(this.debug === 'verbose') {\n      console.info('Spawning Hamster #' + thread_id + ' @ ' + new Date().getTime());\n    }\n  }\n\n  chewGarbage(startOptions) {\n    delete this.init;\n    startOptions = null;\n  }\n\n\n  splitArrayIntoSubArrays(array, n) {\n    let i = 0;\n    let threadArrays = [];\n    let size = Math.ceil(array.length/n);\n    if(array.slice) {\n      while(i < array.length) {\n        threadArrays.push(array.slice(i, i += size));\n      }\n    } else {\n      while (i < array.length) {\n        threadArrays.push(array.subarray(i, i += size));\n      }\n    }\n    return threadArrays;\n  }\n\n  loopAbstraction(input, onSuccess) {\n    let params = {\n      run: this.prepareFunction(input.operator),\n      init: input.startIndex || 0,\n      limit: input.limit,\n      array: input.array,\n      incrementBy: input.incrementBy || 1,\n      dataType: input.dataType || null,\n      worker: this.habitat.worker\n    };\n    this.runHamster(params, function() {\n      let operator = params.run;\n      if(typeof operator === \"string\") {\n        if(params.worker) {\n          operator = eval(\"(\" + operator + \")\");\n        } else {\n          operator = new Function(operator);\n        }\n      }\n      if(!params.limit) {\n        params.limit = params.array.length;\n      }\n      var i = params.init;\n      for (i; i < params.limit; i += params.incrementBy) {\n        rtn.data[i] = operator(params.array[i]);\n      }\n    }, function(rtn) {\n      onSuccess(rtn);\n    }, input.threads, 1, input.dataType);\n  }\n\n  prepareFunction(functionBody) {\n    if(!this.habitat.legacy) {\n      functionBody = String(functionBody);\n      if(!this.habitat.worker) {\n        let startingIndex = (functionBody.indexOf(\"{\") + 1);\n        let endingIndex = (functionBody.length - 1);\n        return functionBody.substring(startingIndex, endingIndex);\n      }\n    }\n    return functionBody;\n  }\n\n  parseJsonOnThread(string, onSuccess) {\n    this.runHamster({input: string}, function() {\n      rtn.data = JSON.parse(params.input);\n    }, function(output) {\n      onSuccess(output[0]);\n    }, 1);\n  }\n\n  stringifyJsonOnThread(json, onSuccess) {\n    this.runHamster({input: json}, function() {\n      rtn.data = JSON.stringify(params.input);\n    }, function(output) {\n      onSuccess(output[0]);\n    }, 1);\n  }\n\n  runHamster(params, fn, onSuccess, workers, aggregate, dataType, memoize, order) {\n    if(!params || !fn) {\n      return 'Error processing for loop, missing params or function';\n    }\n    workers = (this.habitat.legacy ? 1 : (workers || 1));\n    if(dataType) {\n      dataType = dataType.toLowerCase();\n    }\n    let task = this.newTask(this.pool.tasks.length, workers, order, dataType, fn, onSuccess);\n    if(this.cache && memoize) {\n      let result = checkCache(fn, task.input, dataType);\n      if(result && onSuccess) {\n        setTimeout(function() {\n          this.pool.tasks[taskid] = null; //Clean up our task, not needed any longer\n          onSuccess(result);\n        }, 4);\n        return;\n      }\n    }\n    this.work(task, params, fn, onSuccess, aggregate, dataType, memoize, order);\n  }\n\n  randomArray(count, onSuccess) {\n    var randomArray = [];\n    while(count > 0) {\n      randomArray.push(Math.round(Math.random() * (100 - 1) + 1));\n      count -= 1;\n    }\n    onSuccess(randomArray);\n  }\n\n  aggregateThreadOutputs(input, dataType) {\n    if(!dataType || !this.habitat.transferrable) {\n      return input.reduce(function(a, b) {\n        return a.concat(b);\n      });\n    }\n    let i = 0;\n    let len = input.length;\n    let bufferLength = 0;\n    for (i; i < len; i += 1) {\n      bufferLength += input[i].length;\n    }\n    let output = this.processDataType(dataType, bufferLength);\n    let offset = 0;\n    for (i = 0; i < len; i += 1) {\n      output.set(input[i], offset);\n      offset += input[i].length;\n    }\n    return output;\n  }\n\n  checkCache(fn, input, dataType) {\n    let cachedResult = this.cache[fn];\n    if(cachedResult) {\n      if(cachedResult[0] === input && cachedResult[2] === dataType) {\n        return cachedResult;\n      }\n    }\n  }\n\n  memoize(fn, inputArray, output, dataType) {\n    this.cache[fn] = [inputArray, output, dataType];\n  }\n\n  sort(arr, order) {\n    switch(order) {\n      case 'desc':\n      case 'asc':\n        return Array.prototype.sort.call(arr, function(a, b) {\n          return (order === 'asc' ? (a - b) : (b - a)); \n        });\n      case 'ascAlpha':\n        return arr.sort();\n      case 'descAlpha':\n        return arr.reverse();\n      default:\n        return arr;\n    }\n  }\n\n  work(task, params, fn, onSuccess, aggregate, dataType, memoize, order) {\n    let workArray = params.array;\n    if(workArray && task.threads !== 1) {\n      workArray = this.splitArrayIntoSubArrays(workArray, task.threads); //Divide our array into equal array sizes\n    }\n    let food = {};\n    let key;\n    for(key in params) {\n      if(params.hasOwnProperty(key) && key !== 'array') {\n        food[key] = params[key];\n      }\n    }\n    food.fn = this.prepareFunction(fn);\n    food.dataType = dataType;\n    let i = 0;\n    while(i < task.threads) {\n      if(workArray && task.threads !== 1) {\n        this.wheel(workArray[i], food, aggregate, onSuccess, task, task.count, null, memoize);\n      } else {\n        this.wheel(workArray, food, aggregate, onSuccess, task, task.count, null, memoize);\n      }\n      i += 1;\n    }\n  }\n\n\n  assignOutput(task, inputArray) {\n    if(!task || !inputArray || !this.habitat.atomics) {\n      return;\n    }\n    task.output = new SharedArrayBuffer(inputArray.length);\n  }\n\n  trackInput(inputArray, thread_id, task, hamsterFood) {\n    task.input.push({ \n      input: inputArray,\n      workerid: thread_id, \n      taskid: task.id, \n      params: hamsterFood, \n      start: new Date().getTime()\n    });\n  }\n\n  trackThread(task, running, id) {\n    task.workers.push(id); //Keep track of threads scoped to current task\n    this.pool.running.push(id); //Keep track of all currently running threads\n  }\n\n  poolThread(inputArray, hamsterFood, thread_id, cb, task, agg, memoize) {\n    this.pool.pending.push({\n      memoize: memoize,\n      input: inputArray,\n      params: hamsterFood,\n      workerid: thread_id, \n      onSuccess: cb, \n      task: task,\n      aggregate: agg\n    });\n  }\n\n  legacyProcessor(params, inputArray, onSuccess) {\n    setTimeout(function() {\n      var rtn = {\n        success: true, \n        data: []\n      };\n      var params = params;\n      params.array = inputArray;\n      params.fn();\n      if(params.dataType && params.dataType != \"na\") {\n        rtn.data = this.processDataType(params.dataType, rtn.data);\n        rtn.dataType = params.dataType;\n      }\n      onSuccess(rtn);\n    }, 4); //4ms delay (HTML5 spec minimum), simulate threading\n  }\n\n  getOutput(output, aggregate, dataType) {\n    if(aggregate && output.length <= 20) {\n      return this.aggregateThreadOutputs(output, dataType);\n    }\n    return output;\n  }\n\n  processQueue(hamster, item) {\n    if(!item) {\n      return;\n    }\n    this.wheel(item.input, item.params, item.aggregate, item.onSuccess, item.task, item.workerid, hamster, item.memoize); //Assign most recently finished thread to queue item\n  }\n\n  clean(task, id) {\n    this.pool.running.splice(this.pool.running.indexOf(id), 1); //Remove thread from running pool\n    task.workers.splice(task.workers.indexOf(id), 1); //Remove thread from task running pool\n  }\n\n  trainHamster(id, aggregate, onSuccess, task, hamster, memoize) {\n    var libraryContext = this;\n    var onmessage = function(e, results) {\n      libraryContext.clean(task, id);\n      results = e.data.results;\n      task.output[id] = results.data;\n      if(this.debug === 'verbose') {\n        console.info('Hamster #' + id + ' finished ' + '@ ' + e.timeStamp);\n      }\n      if(task.workers.length === 0 && task.count === task.threads) {\n        var output = libraryContext.getOutput(task.output, aggregate, task.dataType);\n        if(task.order) {\n          onSuccess(sort(output, task.order));\n        } else {\n          onSuccess(output);\n        }\n        if(this.debug) {\n          console.info('Execution Complete! Elapsed: ' + ((e.timeStamp - task.input[0].start)/1000) + 's');\n        }\n        libraryContext.pool.tasks[task.id] = null; //Clean up our task, not needed any longer\n        // if(this.cache && memoize) {\n        //   if(task.output[id] && !task.output[id].slice) {\n        //     memoize(task.fn, task.input[0].input, normalizeArray(output), results.dataType);\n        //   } else {\n        //     memoize(task.fn, task.input[0].input, getOutput(task.output, aggregate, results.dataType), results.dataType);\n        //   }\n        // }\n      }\n      if(libraryContext.pool.pending.length !== 0) {\n        libraryContext.processQueue(hamster, libraryContext.pool.pending.shift());\n      } else if(!libraryContext.persistence && !libraryContext.habitat.worker) {\n        hamster.terminate(); //Kill the thread only if no items waiting to run (20-22% performance improvement observed during testing, repurposing threads vs recreating them)\n      }\n    };\n\n    var onerror = function(e) {\n      if(!libraryContext.habitat.worker) {\n        hamster.terminate(); //Kill the thread\n      }\n      libraryContext.pool.errors.push({\n        msg: 'Error Hamster #' + id + ': Line ' + e.lineno + ' in ' + e.filename + ': ' + e.message\n      });\n      console.error('Error Hamster #' + id + ': Line ' + e.lineno + ' in ' + e.filename + ': ' + e.message);\n    };\n\n    if(this.habitat.worker) {\n      hamster.port.onmessage = onmessage;\n      hamster.port.onerror = onerror;\n    } else {\n      hamster.onmessage = onmessage;\n      hamster.onerror = onerror;\n    }   \n  }\n\n  processData(dataType, buffer) {\n    const types = {\n      'uint32': Uint32Array,\n      'uint16': Uint16Array,\n      'uint8': Uint8Array,\n      'uint8clamped': Uint8ClampedArray,\n      'int32': Int32Array,\n      'int16': Int16Array,\n      'int8': Int8Array,\n      'float32': Float32Array,\n      'float64': Float64Array\n    };\n    if(!types[dataType]) {\n      return dataType;\n    }\n    return new types[dataType](buffer);\n  }\n\n  processDataType(dataType, buffer) {\n    if(this.habitat.transferrable) {\n      return this.processData(dataType, buffer);\n    }\n    return buffer;\n  }\n\n  feedHamster(hamster, food) {\n    if(this.habitat.worker) {\n      return hamster.port.postMessage(food);\n    }\n    if(this.habitat.ie10) {\n      return hamster.postMessage(food);\n    }\n    let buffers = [], key;\n    for(key in food) {\n      if(food.hasOwnProperty(key) && food[key] && food[key].buffer) {\n        buffers.push(food[key].buffer);\n      }\n    }\n    return hamster.postMessage(food,  buffers);\n  } \n\n}\n\nmodule.exports = new hamsters();\n\n\n\n// WEBPACK FOOTER //\n// ./src/core.js","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/node-libs-browser/~/process/browser.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}